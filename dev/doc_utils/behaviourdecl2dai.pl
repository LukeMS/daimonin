#!/usr/bin/perl -w

# Generates a xml .dai file from the behaviour declaration file
# server/src/include/behaviourdel.h
#
# Usage: 
#   dev/doc_utils/behaviourdecl2dai.pl < server/src/include/behaviourdecl.h > doc/src/doc/behaviours.dai

# use strict;
use Parse::RecDescent;
use XML::Generator ();

# Enable warnings within the Parse::RecDescent module.

$::RD_ERRORS = 1; # Make sure the parser dies when it encounters an error
$::RD_WARN   = 1; # Enable warnings. This will warn on unused rules &c.
$::RD_HINT   = 1; # Give out hints to help fix problems.

# Cleans up a doxygen-like comment block to raw text
sub doc
{
    my ($raw) = @_;

    # Remove comment start and end markers
    $raw =~ s/^\s*\/\*\*\s*//; 
    $raw =~ s/\*\///;

    $raw =~ s/^\s*\*\s*//gm; # Remove whitespace and * at beginnings of lines
    $raw =~ s/\s*$//gm; # Remove whitespace at line ends

    return $raw
}

sub class
{
    my ($name, $behaviours, $doc) = @_;

    if(defined $doc) { $doc = $::xml->p(@{$doc}) } 
        else { $doc = ""; }

    return $::xml->section($::xml->title("Class $name"), $doc, @{$behaviours});
}

sub behaviour
{
    my ($name, $parameters, $doc) = @_;

    if(defined $doc) { $doc = $::xml->p(@{$doc}) } 
        else { $doc = ""; }

    return $::xml->section($::xml->title("Behaviour $name"), $doc, @{$parameters});
}

sub parameter
{
    my ($name, $type, $flags, $default, $doc) = @_;

    if(defined $doc) { $doc = $::xml->p(@{$doc}) } 
        else { $doc = ""; }

    return 
        $::xml->section(
            $::xml->title("Parameter $name"),
            $::xml->dl(
                $::xml->dt('Type:'), $xml->dd("$type"),
                $::xml->dt('Flags:'), $xml->dd(join(", ", @{$flags})),
                $::xml->dt('Default:'), $xml->dd($default)),
            $doc
            );
}

my $grammar = <<'_EOGRAMMAR_';

start: ccomment(s?) classlist

ccomment: m{/\*[^*].*?\*/}s
bdlcomment: m{/\*\*.*?\*/}s
    { $return = ::doc($item[1]); }

classlist: class(s?)
    { $return = $item[1]; }
class: bdlcomment(?) 'BehaviourClass(' classname ',' behaviourlist ')'
    { $return = ::class($item[3], $item[5], $item[1]); }
classname: /[A-Z_]+/

behaviourlist: behaviour(s) 
    | 'NIL'
    { $return = [$::xml->p("(No behaviours)")]; }
behaviour: bdlcomment(?) 'Behaviour(' behaviourname ',' behaviourfunc ',' parameterlist ')'
    { $return = ::behaviour($item[3], $item[-2], $item[1]) }
behaviourname: /[A-Z_]+/
behaviourfunc: /[a-z_]+/ 

parameterlist: parameter(s) 
    | 'NIL'
    { $return = [$::xml->p("(No parameters)")]; }
parameter: bdlcomment(?) 'Parameter(' behaviourname ',' parametername ',' parametertype ',' parameterflags ',' defaultvalue ')'
    { $return = ::parameter($item[5], $item[7], $item[9], $item[11], $item[1]); }
parametername: /[A-Z_]+/
parametertype: 'INTEGER' | 'STRINGINT' | 'STRING' 
parameterflags: parameterflag(s /\|/)
parameterflag: 'MULTI' | 'SINGLE' | 'OPTIONAL' | 'MANDATORY'
defaultvalue: /"[^"]*"/ | 'NULL' | /-?[0-9]+/

_EOGRAMMAR_

$::xml = XML::Generator->new(':pretty');

my $parser = Parse::RecDescent->new($grammar);
my $file = do { local $/; <> };

print '<?xml version="1.0" encoding="iso-8859-1"?>', "\n";
print '<!DOCTYPE section SYSTEM "../dtd/daidoc.dtd">', "\n";

print $xml->section(
    $xml->title("AI behaviour documentation"),
    $xml->p("This is the autogenerated documentation of the available behaviours and their parameters."),
    @{$parser->start($file)}), "\n";
