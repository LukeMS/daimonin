/*
    Daimonin, the Massive Multiuser Online Role Playing Game
    Server Applicatiom

    Copyright (C) 2001 Michael Toennies

    A split from Crossfire, a Multiplayer game for X-windows.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

    The author can be reached via e-mail to daimonin@nord-com.net
*/

#include <global.h>

#include <aiconfig.h>
#include <ctype.h>

/*#define AI_DEBUG*/

/* Maximum number of ticks a mob remembers an object that it can't see */
#define MAX_KNOWN_OBJ_AGE 200

/* Maximum number of ticks we trust an older rangevector to a known object */
#define MAX_KNOWN_OBJ_RV_AGE 1

/* TODO: we can speed searches up by using smarter data structures here,
 * for example balanced trees or hashtables */
/* List of behavioursets generated by generate_behaviourset() */
static struct mob_behaviourset *generated_behavioursets = NULL;
/* List of behavioursets parsed by parse_behaviourconfig() */
static struct mob_behaviourset *parsed_behavioursets    = NULL;

/*
 * When parsing a message-struct, the msglang struct is used
 * to contain the values.
 * This struct will be expanded as new features are added.
 * When things are stable, it will be parsed only once.
 */

typedef struct _msglang
{
    char           **messages;  /* An array of messages */
    char           ***keywords; /* For each message, an array of strings to match */
} msglang;

extern spell    spells[NROFREALSPELLS];

rv_vector      *get_known_obj_rv(object *op, struct mob_known_obj *known_obj, int maxage);

/*
 * Memory management functions
 */

/* Destructors for the mm system */
void cleanup_mob_known_obj(struct mob_known_obj *data)
{
    FREE_ONLY_HASH(data->last_map);
}

static inline void cleanup_behaviour_parameters(struct mob_behaviour *behaviour)
{
    int                         i;
    struct mob_behaviour_param *param;

    if (behaviour->parameters)
    {
        for (i = 0; i < behaviour->declaration->nrof_params; i++)
        {
            /* Return any multiply defined parameters */
            for (param = behaviour->parameters[i].next; param; param = param->next)
            {
                FREE_ONLY_HASH(param->stringvalue);
                return_poolchunk(param, pool_mob_behaviourparam);
            }

            FREE_ONLY_HASH(behaviour->parameters[i].stringvalue);
        }
        /* Return the base parameter array */
        return_poolarray(behaviour->parameters, behaviour->declaration->nrof_params, pool_mob_behaviourparam);
    }
}

void cleanup_behaviourset(struct mob_behaviourset *data)
{
    int                     i;
    struct mob_behaviour   *tmp;
    for (i = 0; i < NROF_BEHAVIOURCLASSES; i++)
    {
        for (tmp = data->behaviours[i]; tmp; tmp = tmp->next)
        {
            cleanup_behaviour_parameters(tmp);
            return_poolchunk(tmp, pool_mob_behaviour);
        }
    }
}

void cleanup_mob_data(struct mobdata *data)
{
    struct mob_known_obj       *tmp;
    struct mob_behaviourset    *set;

    if (data->pathfinding.path)
        free_path(data->pathfinding.path); 
    FREE_ONLY_HASH(data->pathfinding.goal_map);   
    FREE_ONLY_HASH(data->pathfinding.target_map);   

    for (tmp = data->known_mobs; tmp; tmp = tmp->next)
        return_poolchunk(tmp, pool_mob_knownobj);
    for (tmp = data->known_objs; tmp; tmp = tmp->next)
        return_poolchunk(tmp, pool_mob_knownobj);

    set = data->behaviours;
    set->refcount--;
    if (set->refcount == 0)
    {
        /* Remove from list */
        if (set->next)
            set->next->prev = set->prev;
        if (set->prev)
            set->prev->next = set->next;
        if (set->definition)
        {
            /* Parsed */
            //            LOG(llevDebug, "Parsed behaviourset with refcount==0 being freed...\n");
            if (set == parsed_behavioursets)
                parsed_behavioursets = set->next;
        }
        else
        {
            /* Generated */
            //            LOG(llevDebug, "Generated behaviourset with refcount==0 being freed...\n");
            if (set == generated_behavioursets)
                generated_behavioursets = set->next;
        }
        FREE_ONLY_HASH(set->definition);
        return_poolchunk(set, pool_mob_behaviourset);
    }
}

/* Initializator for the mm system */
void initialize_mob_data(struct mobdata *data)
{
    data->pathfinding.target_obj = NULL;
    data->pathfinding.target_map = NULL;
    data->pathfinding.path_requested = FALSE;
    data->pathfinding.path = NULL;
    data->pathfinding.goal_map = NULL;
    data->pathfinding.best_distance = -1;
    data->pathfinding.tried_steps = 0;

    data->known_mobs = NULL;
    data->known_objs = NULL;

    data->leader = NULL;
    data->enemy = NULL;

    data->behaviours = NULL;
}

/*
 * Behaviourset definition util functions
 */

/* Generate a 32 bit unique hash from the data we use to generate
 * behavioursets */
uint32 bghash(object *op)
{
    uint32  hash    = 0;
    if (QUERY_FLAG(op, FLAG_NO_ATTACK))
        hash |= 1;
    if (QUERY_FLAG(op, FLAG_STAND_STILL))
        hash |= 2;
    if ((op->move_type & HI4) == WPOINT)
        hash |= 4;
    if (QUERY_FLAG(op, FLAG_RANDOM_MOVE))
        hash |= 8;
    if (QUERY_FLAG(op, FLAG_CAST_SPELL))
        hash |= 16;
    if (QUERY_FLAG(op, FLAG_READY_BOW))
        hash |= 32;

    hash <<= 16; /* can reduce to about 5 bits each */
    hash |= ((op->item_race & 0xff) << 8) | ((op->item_level & 0xff));

    hash <<= 8; /* Can reduce to 7 bits at least */
    hash |= (op->run_away & 0xff);

    return hash;
}

/* Set up pointers to default ai definitions in the archetypes */
void init_arch_default_behaviours()
{
    archetype  *at;

    LOG(llevDebug, "Init arch default AI: ");
    for (at = first_archetype; at != NULL; at = (at->more == NULL) ? at->next : at->more)
        if (at->clone.type == TYPE_AI && at->clone.msg && at->clone.other_arch)
        {
            LOG(llevDebug, "%s->'%s' ", STRING_OBJ_NAME(&at->clone.other_arch->clone), STRING_OBJ_NAME(&at->clone));
            at->clone.other_arch->ai = parse_behaviourconfig(at->clone.msg, &at->clone);
        }
    LOG(llevDebug, " Done\n");
}

/* Set up the structs for a behaviour and its parameters */
struct mob_behaviour * init_behaviour(behaviourclass_t classid, int behaviourid)
{
    struct mob_behaviour   *behaviour;

    behaviour = get_poolchunk(pool_mob_behaviour);
    behaviour->declaration = &behaviourclasses[classid].behaviours[behaviourid];
    behaviour->next = NULL;
    if (behaviour->declaration->nrof_params > 0)
    {
        int i;
        behaviour->parameters = get_poolarray(pool_mob_behaviourparam, behaviour->declaration->nrof_params);
        for (i = 0; i < behaviour->declaration->nrof_params; i++)
        {
            behaviour->parameters[i].next = NULL;
            behaviour->parameters[i].stringvalue = NULL;
            behaviour->parameters[i].intvalue = -1;
            behaviour->parameters[i].flags = 0;
        }
    }
    else
    {
        behaviour->parameters = NULL;
    }

    return behaviour;
}

/* Backwards-compability function that creates a behaviourset 
 * from old-style mob parameters (attributes of mob object) */
struct mob_behaviourset * generate_behaviourset(object *op)
{
    struct mob_behaviourset    *set;
    struct mob_behaviour       *last;
    uint32                      hash    = bghash(op);
    int                         i;

    /* First try to find an already generated behaviour with identical
     * parameters */
    for (set = generated_behavioursets; set; set = set->next)
        if (set->bghash == hash)
        {
            //            LOG(llevDebug,"Found existing generated behaviourset for '%s'. refcount = %d\n", STRING_OBJ_NAME(op), set->refcount);
            set->refcount++;
            return set;
        }

    /* Otherwise generate a new behaviourset */
    //    LOG(llevDebug,"Generating behaviourset for %s\n", STRING_OBJ_NAME(op));
    set = get_poolchunk(pool_mob_behaviourset);
    for (i = 0; i < NROF_BEHAVIOURCLASSES; i++)
        set->behaviours[i] = NULL;
    set->refcount = 1;
    set->definition = NULL;
    set->bghash = hash;
    set->next = set->prev = NULL;
    set->attitudes = NULL;

    /* Insert in list */
    set->next = generated_behavioursets;
    if (set->next)
        set->next->prev = set;
    generated_behavioursets = set;

    /* Processes */
    last = set->behaviours[BEHAVIOURCLASS_PROCESSES] = init_behaviour(BEHAVIOURCLASS_PROCESSES,
                                                                      AIBEHAVIOUR_LOOK_FOR_OTHER_MOBS);
    last = last->next = init_behaviour(BEHAVIOURCLASS_PROCESSES, AIBEHAVIOUR_FRIENDSHIP);
    if (!QUERY_FLAG(op, FLAG_NO_ATTACK))
        last = last->next = init_behaviour(BEHAVIOURCLASS_PROCESSES, AIBEHAVIOUR_CHOOSE_ENEMY);

    /* Moves */
    if (QUERY_FLAG(op, FLAG_STAND_STILL))
        last = set->behaviours[BEHAVIOURCLASS_MOVES] = init_behaviour(BEHAVIOURCLASS_MOVES, AIBEHAVIOUR_STAND_STILL);
    else
    {
        last = set->behaviours[BEHAVIOURCLASS_MOVES] = init_behaviour(BEHAVIOURCLASS_MOVES, AIBEHAVIOUR_SLEEP);

        if (op->run_away)
        {
            last = last->next = init_behaviour(BEHAVIOURCLASS_MOVES, AIBEHAVIOUR_RUN_AWAY_FROM_ENEMY);
            last->parameters[AIPARAM_RUN_AWAY_FROM_ENEMY_HP_THRESHOLD].intvalue = op->run_away;   
            last->parameters[AIPARAM_RUN_AWAY_FROM_ENEMY_HP_THRESHOLD].flags |= AI_PARAM_PRESENT;
        }

        if (!QUERY_FLAG(op, FLAG_NO_ATTACK))
        {
            if (QUERY_FLAG(op, FLAG_CAST_SPELL) || QUERY_FLAG(op, FLAG_READY_BOW))
            {
                /* Behaviours for archers/mages only */
                last = last->next = init_behaviour(BEHAVIOURCLASS_MOVES, AIBEHAVIOUR_KEEP_DISTANCE_TO_ENEMY);
                last->parameters[AIPARAM_KEEP_DISTANCE_TO_ENEMY_MIN_DIST].intvalue = (int)
                                                                                     behaviourclasses[BEHAVIOURCLASS_MOVES].behaviours[AIBEHAVIOUR_KEEP_DISTANCE_TO_ENEMY].params[AIPARAM_KEEP_DISTANCE_TO_ENEMY_MIN_DIST].defaultvalue;
                last->parameters[AIPARAM_KEEP_DISTANCE_TO_ENEMY_MAX_DIST].intvalue = (int)
                                                                                     behaviourclasses[BEHAVIOURCLASS_MOVES].behaviours[AIBEHAVIOUR_KEEP_DISTANCE_TO_ENEMY].params[AIPARAM_KEEP_DISTANCE_TO_ENEMY_MAX_DIST].defaultvalue;
                
                last = last->next = init_behaviour(BEHAVIOURCLASS_MOVES, AIBEHAVIOUR_OPTIMIZE_LINE_OF_FIRE);                
                
            }
            else
            {
                /* Behaviours for melee fighters */
                /*
                last = last->next = init_behaviour(
                        BEHAVIOURCLASS_MOVES, AIBEHAVIOUR_STEP_BACK_AFTER_SWING);
                last->parameters[AIPARAM_STEP_BACK_AFTER_SWING_DIST].intvalue = (int)behaviourclasses[BEHAVIOURCLASS_MOVES].behaviours[AIBEHAVIOUR_STEP_BACK_AFTER_SWING].params[AIPARAM_STEP_BACK_AFTER_SWING_DIST].defaultvalue;
                */

                last = last->next = init_behaviour(BEHAVIOURCLASS_MOVES, AIBEHAVIOUR_AVOID_LINE_OF_FIRE);
            }

            last = last->next = init_behaviour(BEHAVIOURCLASS_MOVES, AIBEHAVIOUR_MOVE_TOWARDS_ENEMY);
            last = last->next = init_behaviour(BEHAVIOURCLASS_MOVES, AIBEHAVIOUR_MOVE_TOWARDS_ENEMY_LAST_KNOWN_POS);
            last = last->next = init_behaviour(BEHAVIOURCLASS_MOVES, AIBEHAVIOUR_SEARCH_FOR_LOST_ENEMY);
        }
        if ((op->move_type & HI4) == WPOINT)
            last = last->next = init_behaviour(BEHAVIOURCLASS_MOVES, AIBEHAVIOUR_MOVE_TOWARDS_WAYPOINT);
        if (QUERY_FLAG(op, FLAG_RANDOM_MOVE))
        {
            last = last->next = init_behaviour(BEHAVIOURCLASS_MOVES, AIBEHAVIOUR_MOVE_RANDOMLY);
            if (op->item_race != 255)
            {
                last->parameters[AIPARAM_MOVE_RANDOMLY_XLIMIT].intvalue = op->item_race;   
                last->parameters[AIPARAM_MOVE_RANDOMLY_XLIMIT].flags |= AI_PARAM_PRESENT;
            }
            if (op->item_level != 255)
            {
                last->parameters[AIPARAM_MOVE_RANDOMLY_YLIMIT].intvalue = op->item_level;   
                last->parameters[AIPARAM_MOVE_RANDOMLY_YLIMIT].flags |= AI_PARAM_PRESENT;
            }
        }
        last = last->next = init_behaviour(BEHAVIOURCLASS_MOVES, AIBEHAVIOUR_MOVE_TOWARDS_HOME);
    }

    /* Actions */
    if (!QUERY_FLAG(op, FLAG_NO_ATTACK))
    {
        last = set->behaviours[BEHAVIOURCLASS_ACTIONS] = init_behaviour(BEHAVIOURCLASS_ACTIONS,
                                                                        AIBEHAVIOUR_MELEE_ATTACK_ENEMY);
        if (QUERY_FLAG(op, FLAG_CAST_SPELL))
            last = last->next = init_behaviour(BEHAVIOURCLASS_ACTIONS, AIBEHAVIOUR_SPELL_ATTACK_ENEMY);
        if (QUERY_FLAG(op, FLAG_READY_BOW))
            last = last->next = init_behaviour(BEHAVIOURCLASS_ACTIONS, AIBEHAVIOUR_BOW_ATTACK_ENEMY);
    }

    return set;
}

/* Parse a stringint value in the form "string:int"
 * to separate string and int values.
 * Returns: 0 at success, non-zero on failure */
static int parse_stringint_parameter(struct mob_behaviour_param *param, const char *value)
{
    char *sep = strchr(value, ':'); 
    char buf[256];
    if(sep && sep > value && *(sep+1) != '\0')
    {
        strncpy(buf, value, sep-value);
        /* TODO: an add_string_l(buf, length) function to avoid copying here */
        buf[sep-value] = '\0';
        param->stringvalue = add_string(buf);
        param->intvalue = atoi(sep+1);
//        LOG(llevDebug, "Stringint: %s:%d\n", param->stringvalue, param->intvalue);
        return 0;
    } else
        return -1;
}

/* Parse a single parameter=value pair into a 
 * mob_behaviour_param struct 
 * Returns: 0 at success, non-zero on failure */
static int parse_behaviour_parameters(const char *start, const char *end, struct mob_behaviour *behaviour)
{
    char                        namebuf[256], valuebuf[256], *ptr;
    struct mob_behaviour_param *param;
    struct behaviourparam_decl *paramdecl;
    int                         i;

    while (start < end)
    {
        while (isspace(*start))
            start++;
        if (start >= end)
            break;

        /* Copy parameter name */
        ptr = namebuf;
        while (*start && !isspace(*start) && *start != '=')
            *ptr++ = *start++;
        *ptr = '\0';

        /* make sure we have an equals sign and a value */
        if (*start++ != '=' || start >= end)
            return -1;

        /* Copy parameter value */
        ptr = valuebuf;
        while (*start && !isspace(*start))
            *ptr++ = *start++;
        *ptr = '\0';

        if (ptr == valuebuf)
            return -1;

        /* Find the parameter in the declaration */
        /* TODO: small speedup by storing parameter declarations
         * in binary heap or balanced binary tree */
        paramdecl = NULL;
        for (i = 0; i < behaviour->declaration->nrof_params; i++)
        {
            if (strcasecmp(namebuf, behaviour->declaration->params[i].name) == 0)
            {
                paramdecl = &behaviour->declaration->params[i];
                param = &behaviour->parameters[i];
                break;
            }
        }

        if (paramdecl == NULL)
        {
            LOG(llevBug, "BUG: undefined parameter %s for behaviour %s\n", namebuf, behaviour->declaration->name);
            continue;
        }

        /* Handle multiply defined parameters */
        if (param->flags & AI_PARAM_PRESENT)
        {
            if (paramdecl->attribs & AI_MULTI_PARAM)
            {
                param->next = get_poolchunk(pool_mob_behaviourparam);
                param = param->next;
                param->next = NULL;
                param->stringvalue = NULL;
                param->intvalue = 0;
                param->flags = 0;
            }
            else
            {
                LOG(llevBug, "BUG: parameter %s given twice for behaviour %s\n", namebuf, behaviour->declaration->name);
                continue;
            }
        }
                
        /* Fill in fields depending on type */
        switch (paramdecl->type)
        {
            case AI_INTEGER_TYPE:
              param->intvalue = atoi(valuebuf);
              param->flags |= AI_PARAM_PRESENT;
              break;

            case AI_STRING_TYPE:
              param->stringvalue = add_string(valuebuf);
              param->flags |= AI_PARAM_PRESENT;
        LOG(llevDebug, "parameter %s for behaviour %s, value %s\n", namebuf, behaviour->declaration->name, valuebuf);

              break;
              
            case AI_STRINGINT_TYPE:
              if(parse_stringint_parameter(param, valuebuf))
                  LOG(llevBug, "BUG: Bad STRINGINT format (\"%s\") for parameter %s\n", valuebuf, namebuf);
              else 
                  param->flags |= AI_PARAM_PRESENT;
              break;

            default:
              LOG(llevBug, "BUG: unknown type for parameter %s\n", namebuf);
              break;
        }
    }

    /* Finally, make sure all mandatory parameters were supplied, and
     * fill in default values for non-present optional parameters */
    for (i = 0; i < behaviour->declaration->nrof_params; i++)
    {
        if (!behaviour->parameters[i].flags & AI_PARAM_PRESENT)
        {
            if (behaviour->declaration->params[i].attribs & AI_MANDATORY_PARAM)
            {
                LOG(llevBug, "BUG: mandatory parameter %s not given for behaviour %s\n",
                    behaviour->declaration->params[i].name, behaviour->declaration->name);
                cleanup_behaviour_parameters(behaviour);
                behaviour->parameters = NULL;
                return -1;
            }
            else
            {
                switch (behaviour->declaration->params[i].type)
                {
                    case AI_INTEGER_TYPE:
                      behaviour->parameters[i].intvalue = (int) behaviour->declaration->params[i].defaultvalue;
                      break;
                    case AI_STRING_TYPE:
                      behaviour->parameters[i].stringvalue = add_string(behaviour->declaration->params[i].defaultvalue);
                      break;
                    case AI_STRINGINT_TYPE:
                      if(parse_stringint_parameter(&behaviour->parameters[i], behaviour->declaration->params[i].defaultvalue))
                          LOG(llevBug, "BUG: Bad STRINGINT default value (\"%s\") for parameter %s:%s\n", valuebuf, behaviour->declaration->name, behaviour->declaration->params[i].name);
                      break;
                }
            }
        }
    }

    return 0;
}

static struct mob_behaviour *setup_plugin_behaviour(
        behaviourclass_t class, 
        char *buf, char *colonpos, const char *tok_end, const char *conf_text)
{
    int plugin_index, behaviour_index, options_index;
    int behaviour_id;
    struct mob_behaviour *new_behaviour = NULL;
    const char *line_end = conf_text;
        
    /* Set up a plugin:behaviour */
    switch(class) {
        case BEHAVIOURCLASS_PROCESSES:
            behaviour_id = AIBEHAVIOUR_PLUGIN_PROCESS;
            plugin_index = AIPARAM_PLUGIN_PROCESS_PLUGIN;
            behaviour_index = AIPARAM_PLUGIN_PROCESS_BEHAVIOUR;
            options_index = AIPARAM_PLUGIN_PROCESS_OPTIONS;
            break;
        case BEHAVIOURCLASS_MOVES:
            behaviour_id = AIBEHAVIOUR_PLUGIN_MOVE;
            plugin_index = AIPARAM_PLUGIN_MOVE_PLUGIN;
            behaviour_index = AIPARAM_PLUGIN_MOVE_BEHAVIOUR;
            options_index = AIPARAM_PLUGIN_MOVE_OPTIONS;
            break;
        case BEHAVIOURCLASS_ACTIONS:
            behaviour_id = AIBEHAVIOUR_PLUGIN_ACTION;
            plugin_index = AIPARAM_PLUGIN_ACTION_PLUGIN;
            behaviour_index = AIPARAM_PLUGIN_ACTION_BEHAVIOUR;
            options_index = AIPARAM_PLUGIN_ACTION_OPTIONS;
            break;
        default:                        
            LOG(llevBug, "BUG: behaviour %s without class\n", buf);
            break;
    }
    new_behaviour = init_behaviour(class, behaviour_id);
   
    /* Split up plugin and behaviour names. Validate plugin */
    *colonpos = '\0';
    if(findPlugin(buf) == -1)
    {
        LOG(llevBug, "BUG: behaviour plugin %s unknown\n", buf);
        return NULL;
    }              
    
    new_behaviour->parameters[plugin_index].stringvalue = add_string(buf);
    new_behaviour->parameters[plugin_index].flags |= AI_PARAM_PRESENT;
    
    new_behaviour->parameters[behaviour_index].stringvalue = add_string(colonpos+1);
    new_behaviour->parameters[behaviour_index].flags |= AI_PARAM_PRESENT;
    
    /* See if there were any parameters */
    while (*line_end == '\n' || *line_end == '\r')
        line_end--;
    
    if(tok_end < line_end) {
       new_behaviour->parameters[options_index].stringvalue = add_lstring(tok_end + 1, line_end - tok_end);
       new_behaviour->parameters[options_index].flags |= AI_PARAM_PRESENT;
    }

    return new_behaviour;
}

static struct mob_behaviour *setup_behaviour(
        object *op, behaviourclass_t class, 
        char *buf, const char *tok_end, const char *conf_text)
{
    int behaviour_id;
    struct mob_behaviour *new_behaviour = NULL;
    
    /* find the corresponding behaviour declaration */
    /* TODO: here we can speed up search significantly using a
     * perfect hash function */
    
    for (behaviour_id = 0; behaviourclasses[class].behaviours[behaviour_id].func; behaviour_id++)
    {
        if (!strcasecmp(buf, behaviourclasses[class].behaviours[behaviour_id].name))
        {
            new_behaviour = init_behaviour(class, behaviour_id);
            //                    LOG(llevDebug,"    behaviour %s\n", buf);
            break;
        }
    }
    
    if (new_behaviour == NULL)
    {
        LOG(llevBug, "BUG: unknown %s behaviour %s of %s\n", behaviourclasses[class].name, buf,
            STRING_OBJ_NAME(op));
        return NULL;
    } 

    /* Parse parameters to behaviour */
    if (new_behaviour->parameters)
    {
        /* Parse behaviour parameters */
        if (parse_behaviour_parameters(tok_end, conf_text, new_behaviour) == -1)
        {
            LOG(llevBug, "BUG: bad parameterlist for %s of %s\n", buf, STRING_OBJ_NAME(op));
            return_poolchunk(new_behaviour, pool_mob_behaviour);
            return NULL;
        }
    }

    return new_behaviour;
}

struct mob_behaviourset * parse_behaviourconfig(const char *conf_text, object *op)
{
    struct mob_behaviourset    *behaviourset;
    struct mob_behaviour       *last_behaviour[NROF_BEHAVIOURCLASSES];
    struct mob_behaviour       *new_behaviour;
    behaviourclass_t            class = BEHAVIOURCLASS_NONE;

    int         i;

    const char *tok_start, *tok_end;
    char        buf[HUGE_BUF];

    /* First see if we have already parsed an identical behaviourset */
    for (behaviourset = parsed_behavioursets; behaviourset; behaviourset = behaviourset->next)
    {
        /* This assumes that conf_text is a hashed string! */
        if (behaviourset->definition == conf_text)
        {
            //            LOG(llevDebug,"Found previously parsed behaviourset for '%s'. refcount = %d\n", STRING_OBJ_NAME(op), behaviourset->refcount);
            behaviourset->refcount++;
            return behaviourset;
        }
    }

    /* init */
    behaviourset = get_poolchunk(pool_mob_behaviourset);
    for (i = 0; i < NROF_BEHAVIOURCLASSES; i++)
    {
        behaviourset->behaviours[i] = NULL;
        last_behaviour[i] = NULL;
    }
    behaviourset->prev = behaviourset->next = NULL;
    behaviourset->refcount = 1;
    behaviourset->definition = add_refcount(conf_text);
    behaviourset->bghash = 0;
    behaviourset->attitudes = NULL;

    /* Insert in list */
    behaviourset->next = parsed_behavioursets;
    if (behaviourset->next)
        behaviourset->next->prev = behaviourset;
    parsed_behavioursets = behaviourset;

    //    LOG(llevDebug,"parse_behaviourconfig(): Parsing for %s:\n", STRING_OBJ_NAME(op));
    while (*conf_text)
    {
        /* skip whitespace */
        if (isspace(*conf_text))
        {
            conf_text++;
            continue;
        }

        /* skip comments */
        if (*conf_text == '#')
        {
            while (*conf_text && *conf_text != '\r' && *conf_text != '\n')
                conf_text++;
            continue;
        }

        /* Search for next whitespace */
        tok_start = tok_end = conf_text;
        while (*tok_end && !isspace(*tok_end))
            tok_end++;

        if (tok_end - tok_start >= 2 && *(tok_end - 1) == ':')
        {
            int i;

            /* extract class header */
            while (*tok_start != ':')
            {
                buf[tok_start - conf_text] = *tok_start;
                tok_start++;
            }
            buf[tok_start - conf_text] = '\0';

            //            LOG(llevDebug,"  class %s:\n", buf);

            /* look up class header */            
            for (i = 0; i < NROF_BEHAVIOURCLASSES; i++)
            {
                if (strcasecmp(buf, behaviourclasses[i].name) == 0)
                {
                    class   = i;
                    break;
                }
            }
            if (i == NROF_BEHAVIOURCLASSES)
            {
                LOG(llevBug, "BUG: unknown class %s of %s\n", buf, STRING_OBJ_NAME(op));
                break;
            }

            /* find EOL */
            while (*conf_text && *conf_text != '\r' && *conf_text != '\n')
                conf_text++;
        }
        else
        {
            char *colonpos = NULL;

            /* extract behaviour name */
            while (tok_start < tok_end)
            {
                buf[tok_start - conf_text] = *tok_start;

                /* Separator char for plugin:behaviour */
                if(*tok_start == ':')
                    colonpos = &buf[tok_start - conf_text];

                tok_start++;
            }
            buf[tok_start - conf_text] = '\0';

            /* behaviour line, find EOL */
            while (*conf_text && *conf_text != '\r' && *conf_text != '\n')
                conf_text++;

            /* Make sure current class is valid */
            if (class == BEHAVIOURCLASS_NONE)
            {
                LOG(llevBug, "BUG: behaviour %s of %s without class\n", buf, STRING_OBJ_NAME(op));
                continue;
            }

            if(colonpos)
                new_behaviour = setup_plugin_behaviour(class, buf, colonpos, tok_end, conf_text);
            else {
                new_behaviour = setup_behaviour(op, class, buf, tok_end, conf_text);
                /* Special handling for some behaviours */
                if(new_behaviour && class == BEHAVIOURCLASS_PROCESSES && 
                        new_behaviour->declaration->id == AIBEHAVIOUR_ATTITUDE)
                    behaviourset->attitudes = new_behaviour->parameters;
            }

            if(new_behaviour == NULL) 
            {
                LOG(llevBug, "BUG: Failed setting up behaviour for %s\n", STRING_OBJ_NAME(op));
                continue;
            }
            
            /* If everything checks out, add the behaviour to the list */ 
            if (last_behaviour[class] == NULL)
                behaviourset->behaviours[class] = new_behaviour;
            else
                last_behaviour[class]->next = new_behaviour;
            last_behaviour[class] = new_behaviour;
            new_behaviour->next = NULL;
        }
    }

    return behaviourset;
}

/* 
 * In the case of no mob ai object, first we will first 
 * fall back to an arch-default for that mob, then a race-default and 
 * finally a global default.
 */
struct mob_behaviourset * setup_behaviours(object *op)
{
    object *conf_obj    = NULL;

    /* Find mob's behaviour configuration object */
    for (conf_obj = op->inv; conf_obj; conf_obj = conf_obj->below)
        if (conf_obj->type == TYPE_AI)
            break;

    /* Configuration from mob, arch, race or generator? */
    if (conf_obj && conf_obj->msg)
        return parse_behaviourconfig(conf_obj->msg, op);
    else
    {
        //        LOG(llevDebug,"parse_behaviourconfig(): No object AI for '%s', looking for arch AI, then race AI.\n", STRING_OBJ_NAME(op));
        if (op->arch->ai)
        {
            //            LOG(llevDebug,"parse_behaviourconfig(): found arch AI for %s.\n", STRING_OBJ_NAME(op));
            op->arch->ai->refcount++;
            return op->arch->ai;
        }
        else if (op->race)
        {
            racelink   *race    = find_racelink(op->race);
            if (race && race->ai)
            {
                //                LOG(llevDebug,"parse_behaviourconfig(): found race AI for %s.\n", STRING_OBJ_NAME(op));
                race->ai->refcount++;
                return race->ai;
            }
        } 

        //            LOG(llevDebug,"parse_behaviourconfig(): No arch or race AI for '%s'. Generating a custom one\n", STRING_OBJ_NAME(op));
    }

    return generate_behaviourset(op);
}

/*
 * A few random unsorted utility functions
 */

/* Beginnings of can_see_obj */
/* known_obj is optional but increases efficiency somewhat
 * by using caching data in the known_obj struct
 */
int mob_can_see_obj(object *op, object *obj, struct mob_known_obj *known_obj)
{
    int  aggro_range, stealth_range;

    /* Cache values */
    static tag_t cached_op_tag, cached_obj_tag;
    static uint32 cache_time;
    static int cached_result;

    rv_vector   rv, *rv_p = NULL;

    /* Quick answer if possible */
    if (known_obj && known_obj->last_seen == ROUND_TAG)
        return TRUE;

    /* Try using cache */
    if (cached_op_tag == op->count && cached_obj_tag == obj->count &&
                    cache_time == ROUND_TAG)
        return cached_result;
    
    /* Invisibility */
    if (QUERY_FLAG(obj, FLAG_IS_INVISIBLE) && !QUERY_FLAG(op, FLAG_SEE_INVISIBLE))
        return FALSE;

    aggro_range = op->stats.Wis; /* wis is basic sensing range */

    /* Extra range to alerted monsters */
    if (op->enemy) {
        aggro_range += 3;
        if (op->enemy == obj)
            aggro_range += 3;
    }

    /* Much less range if asleep or blind */
    if (QUERY_FLAG(op, FLAG_SLEEP) || QUERY_FLAG(op, FLAG_BLIND))
        aggro_range /= 2;

    /* Alternative sensing range for stealthy targets */
    stealth_range = MAX(MIN_MON_RADIUS, aggro_range - 2);

    /* Get the rangevector, trying to use a cached version first */
    if (known_obj)
        rv_p = get_known_obj_rv(op, known_obj, MAX_KNOWN_OBJ_RV_AGE);
    else if (get_rangevector(op, obj, &rv, 0))
        rv_p = &rv;
    
    if (rv_p == NULL)
        cached_result = FALSE;
    else if ((int) rv_p->distance > (QUERY_FLAG(obj, FLAG_STEALTH) ? stealth_range : aggro_range))
        cached_result = FALSE;
    else
        cached_result = TRUE;

    cached_op_tag = op->count;
    cached_obj_tag = obj->count;
    cache_time = ROUND_TAG;

    /* TODO also test darkness, stealth detection, LOS etc */
    return cached_result;
}

/* TODO: these two new functions are already obsolete and should be replaced 
 * with configuration options in the ai_friendship behaviour,
 * but they serve well as a base...
 */
int is_enemy_of(object *op, object *obj)
{
    /* TODO: add a few other odd types here, such as god & golem */
    if (!obj->type == PLAYER || !obj->type == MONSTER || op == obj)
        return FALSE;

    /* Unagressive mobs are never enemies to anything (?) */
    if (QUERY_FLAG(op, FLAG_UNAGGRESSIVE) || QUERY_FLAG(obj, FLAG_UNAGGRESSIVE))
        return FALSE;

    /* TODO: this needs to be sorted out better */
    if (QUERY_FLAG(op, FLAG_FRIENDLY))
    {
        if (QUERY_FLAG(obj, FLAG_MONSTER) && !QUERY_FLAG(obj, FLAG_FRIENDLY))
            return TRUE;
    }
    else
    {
        if (QUERY_FLAG(obj, FLAG_FRIENDLY) || obj->type == PLAYER)
            return TRUE;
    }

    return FALSE;
}

int is_friend_of(object *op, object *obj)
{
    /* TODO: add a few other odd types here, such as god & golem */
    if (!obj->type == PLAYER || !obj->type == MONSTER || !op->type == PLAYER || !op->type == MONSTER || op == obj)
        return FALSE;

    /* TODO: this needs to be sorted out better */
    if (QUERY_FLAG(op, FLAG_FRIENDLY) || op->type == PLAYER)
    {
        if (!QUERY_FLAG(obj, FLAG_MONSTER) || QUERY_FLAG(obj, FLAG_FRIENDLY) || obj->type == PLAYER)
        {
            return TRUE;
        }
    }
    else
    {
        if (!QUERY_FLAG(obj, FLAG_FRIENDLY) && obj->type != PLAYER)
        {
            return TRUE;
        }
    }

    return FALSE;
}

/*
 * Get the rangevector to a known object. If an earlier calculated rangevector is 
 * older than maxage then we calculate a new one (set maxage to 0 to force update).
 * Returns a pointer to the rangevector, or NULL if get_rangevector() failed.
 */
rv_vector * get_known_obj_rv(object *op, struct mob_known_obj *known_obj, int maxage)
{
    if (op == NULL || known_obj == NULL)
        return NULL;    

    if (ROUND_TAG - known_obj->rv_time >= (uint32) maxage || known_obj->rv_time == 0 || maxage == 0)
    {
        /*
        if(!mob_can_see_obj(op, known_obj->obj, NULL)) {
            mapstruct *map = ready_map_name(known_obj->last_map, MAP_NAME_SHARED);
            if(get_rangevector_from_mapcoords(op->map, op->x, op->y,
                        map, known_obj->last_x, known_obj->last_y, 
                        &known_obj->rv, RV_EUCLIDIAN_DISTANCE)) 
            {
                known_obj->rv_time = global_round_tag;
            } else 
            {
                known_obj->rv_time = 0;
                return NULL;
            }
        }
        */

        if (get_rangevector(op, known_obj->obj, &known_obj->rv, 0))
        {
            known_obj->rv_time = ROUND_TAG;
        }
        else
        {
            known_obj->rv_time = 0;
            return NULL;
        }
    }

    /* hotfix for this bug. part should here NOT be NULL */
    if (!known_obj->rv.part)
    {
        LOG(-1, "CRASHBUG: rv->part == NULL for %s on map %s with enemy %s and map %s\n", query_name(op),
            op->map ? STRING_SAFE(op->map->path) : "NULL", query_name(known_obj->obj),
            known_obj->obj ? STRING_SAFE(known_obj->obj->map ? STRING_SAFE(known_obj->obj->map->path) : "NULL") : "NULL");
        return NULL;
    }
    return &known_obj->rv;
}

/* TODO: make a real behaviour... */
#if 0
void npc_call_for_help(object *op) {
  struct mob_known_obj *friend;
  
  /* TODO: remember to check that the called has MOB_DATA set up before doing anything else... */
  /* TODO: use tmp_friendship? */
  for(friend = MOB_DATA(op)->friends; friend; friend=friend->next) {
      if(friend->friendship >= FRIENDSHIP_HELP && friend->ob->enemy == NULL)  {
          rv_vector *rv = get_known_obj_rv(op, friend, MAX_KNOWN_OBJ_RV_AGE);
          if(rv && rv->distance < 4) {
              /* TODO: also check reverse friendship */
              /* TODO: -friendship here dependant on +friendship towards tmp */
              register_npc_known_obj(friend->ob, op->enemy, FRIENDSHIP_ATTACK);
          }
      }
  }
}
#endif

int calc_friendship_from_attitude(object *op, object *other)    
{
    int friendship = 0;
    struct mob_behaviour_param *attitudes = MOB_DATA(op)->behaviours->attitudes;
    struct mob_behaviour_param *tmp;

    if(attitudes == NULL)
        return 0;

    /* Race attitude */
    if(attitudes[AIPARAM_ATTITUDE_RACE].flags & AI_PARAM_PRESENT)
    {
        for(tmp = &attitudes[AIPARAM_ATTITUDE_RACE]; tmp != NULL;
                tmp = tmp->next)
        {
            if(other->race && tmp->stringvalue == other->race)
                friendship += tmp->intvalue;
        }
    }
    
    /* Arch attitude */
    if(attitudes[AIPARAM_ATTITUDE_ARCH].flags & AI_PARAM_PRESENT)
    {
        for(tmp = &attitudes[AIPARAM_ATTITUDE_ARCH]; tmp != NULL;
                tmp = tmp->next)
        {
            if(other->arch->name && tmp->stringvalue == other->arch->name)
                friendship += tmp->intvalue;
        }
    }
    
    /* Named object attitude */
    if(attitudes[AIPARAM_ATTITUDE_NAME].flags & AI_PARAM_PRESENT)
    {
        for(tmp = &attitudes[AIPARAM_ATTITUDE_NAME]; tmp != NULL;
                tmp = tmp->next)
        {
            if(other->name && tmp->stringvalue == other->name)
                friendship += tmp->intvalue;
        }
    }

    LOG(llevDebug, "Attitude friendship modifier: %d (%s->%s)\n", friendship, STRING_OBJ_NAME(op), STRING_OBJ_NAME(other));


    return friendship;
}

/* register a new enemy or friend for the NPC */
struct mob_known_obj * register_npc_known_obj(object *npc, object *other, int friendship)
{
    struct mob_known_obj   *tmp;
    struct mob_known_obj   *last    = NULL;
    int i;

    if (npc == NULL)
    {
#ifdef AI_DEBUG
        LOG(llevDebug, "register_npc_known_obj(): Called with NULL npc obj\n");
#endif
        return NULL;
    }

    if (other == NULL)
    {
#ifdef AI_DEBUG
        LOG(llevDebug, "register_npc_known_obj(): Called with NULL other obj\n");
#endif
        return NULL;
    }

    if (npc == other)
    {
#ifdef AI_DEBUG
        LOG(llevDebug, "register_npc_known_obj(): Called for itself '%s'\n", STRING_OBJ_NAME(npc));
#endif
        return NULL;
    }

    /* 
     * this is really needed. 
    * a hitter object can be a "system object" ...even a object
    * in the inventory of npc (like a disease). These objects have
    * usually no map.
    *
    * Gecko: Hmm... I have to fix this to be able to handle non-mob objects
    * TODO: I also have to fix the "crash if no map" problem.
    */
    if (other->type != PLAYER && !QUERY_FLAG(other, FLAG_ALIVE))
    {
#ifdef AI_DEBUG
        LOG(llevDebug, "register_npc_known_obj(): Called for non PLAYER/IS_ALIVE '%s'\n", STRING_OBJ_NAME(npc));
#endif
        return NULL;
    }
    
    if (npc->type != MONSTER)
    {
#ifdef AI_DEBUG
        LOG(llevDebug, "register_npc_known_obj(): Called on non-mob object '%s' type %d\n", STRING_OBJ_NAME(npc),
            npc->type);
#endif
        return NULL;
    }    

    /* this check will hopefully be unnecessary in the future */
    if (MOB_DATA(npc) == NULL)
    {
#ifdef AI_DEBUG
        LOG(llevDebug, "register_npc_known_obj(): No mobdata (yet) for '%s'\n", STRING_OBJ_NAME(npc));
#endif
        return NULL;
    }

    /* TODO: get rid of flag_unaggressive and use only friendship */
    if (friendship < 0 && QUERY_FLAG(npc, FLAG_UNAGGRESSIVE))
    {
        CLEAR_FLAG(npc, FLAG_UNAGGRESSIVE);
        friendship += FRIENDSHIP_ATTACK;
    }

    /* Does npc already know this other? */
    for (tmp = MOB_DATA(npc)->known_mobs; tmp; tmp = tmp->next)
    {
        if (tmp->obj == other && tmp->obj_count == other->count)
        {
            tmp->last_seen = ROUND_TAG;
            FREE_AND_ADD_REF_HASH(tmp->last_map, other->map->path);
            tmp->last_x = other->x;
            tmp->last_y = other->y;
            tmp->friendship += friendship;
            /*            if(friendship)
                            LOG(llevDebug,"register_npc_known_obj(): '%s' changed mind about '%s'. friendship: %d -> %d\n",  STRING_OBJ_NAME(npc), STRING_OBJ_NAME(other), tmp->friendship - friendship, tmp->friendship);*/
            return tmp;
        }
        last = tmp;
    }

    /* TODO: keep count of enemies and push out less
     * important if new ones are added beyond a reasonable max number */

    /* No, it is a new object */
    tmp = get_poolchunk(pool_mob_knownobj);
    tmp->next = NULL;
    tmp->prev = last;
    tmp->obj = other;
    tmp->obj_count = other->count;

    tmp->last_map = add_refcount(other->map->path);
    tmp->last_x = other->x;
    tmp->last_y = other->y;

    tmp->last_seen = ROUND_TAG;
    tmp->rv_time = 0; /* Makes cached rv invalid */

    tmp->friendship = friendship + calc_friendship_from_attitude(npc, other);
    tmp->attraction = 0;
    tmp->tmp_friendship = 0;
    tmp->tmp_attraction = 0;
    
    for(i=0; i<=NROF_AI_KNOWN_OBJ_FLAGS/32; i++)
        tmp->flags[i] = 0;

    /* Insert last in list of known objects */
    if (last)
        last->next = tmp;
    else
        MOB_DATA(npc)->known_mobs = tmp;        

    //    LOG(llevDebug,"register_npc_known_obj(): '%s' detected '%s'. friendship: %d\n",  STRING_OBJ_NAME(npc), STRING_OBJ_NAME(other), tmp->friendship);

    return tmp;
}

/*
 * Waypoint utility functions 
 */

/* Find a monster's currently active waypoint, if any */
object * get_active_waypoint(object *op)
{
    object *wp  = NULL;

    for (wp = op->inv; wp != NULL; wp = wp->below)
        if (wp->type == TYPE_WAYPOINT_OBJECT && QUERY_FLAG(wp, WP_FLAG_ACTIVE))
            break;

    return wp;
}

/* Find a monster's current return-home wp, if any */
object * get_return_waypoint(object *op)
{
    object *wp  = NULL;

    for (wp = op->inv; wp != NULL; wp = wp->below)
        if (wp->type == TYPE_WAYPOINT_OBJECT && QUERY_FLAG(wp, FLAG_REFLECTING))
            break;

    return wp;
}

/* Find a monster's waypoint by name (used for getting the next waypoint) */
object * find_waypoint(object *op, const char *name)
{
    object *wp  = NULL;

    if (name == NULL)
        return NULL;

    for (wp = op->inv; wp != NULL; wp = wp->below)
        if (wp->type == TYPE_WAYPOINT_OBJECT && strcmp(wp->name, name) == 0)
            break;

    return wp;
}

/*
 * Some other utility functions
 */

int can_hit_melee(object *ob1, object *ob2, rv_vector *rv)
{
    if (QUERY_FLAG(ob1, FLAG_CONFUSED) && !(RANDOM() % 3))
        return 0;
    return abs(rv->distance_x) < 2 && abs(rv->distance_y) < 2;
}

/* modes: 
 * 1 - exact 45 deg
 * 2 - 45 deg +- one tile
 * 3 - free 360 deg LOF
 *
 * TODO: rename to is_in_line_of_fire
 */
int can_hit_missile(object *ob1, object *ob2, rv_vector *rv, int mode)
{
    /* TODO: actually perform a rough line of sight calculation */

    switch (mode)
    {
        case 1:
          /* exact 45 deg */
        default:
          return rv->distance_x == 0 || rv->distance_y == 0 || abs(rv->distance_x) - abs(rv->distance_y) == 0;                
        case 2:
          /* 45 deg +- one tile */
          return abs(rv->distance_x) <= 1
              || abs(rv->distance_y) <= 1
              || abs(abs(rv->distance_x) - abs(rv->distance_y)) <= 1;

        case 3:
          /* free 360 deg line of fire */
          return TRUE;
    }
}

/* Ugly hack for now... */
int mapcoord_in_line_of_fire(object *op1, mapstruct *map, int x, int y, int mode)
{
    rv_vector rv;
    get_rangevector_from_mapcoords(op1->map, op1->x, op1->y, map, x, y, &rv, RV_DIAGONAL_DISTANCE);
    return can_hit_missile(op1, NULL, &rv, mode);
}

/* Normalize a given map path and make sure it is valid and 
 * that the map is loaded. Can return NULL in case of failure */
static inline mapstruct * normalize_and_ready_map(mapstruct *defmap, const char **path)
{
    /* Default map is current map */
    if (path == NULL || *path == NULL || **path == '\0')
        return defmap; 

    /* If path not normalized: normalize it */
    if (**path != '/')
    {
        char    temp_path[HUGE_BUF];
        normalize_path(defmap->path, *path, temp_path);
        FREE_AND_COPY_HASH(*path, temp_path);
    }

    /* check if we are already on the map */
    if (*path == defmap->path)
        return defmap;
    else
        return ready_map_name(*path, MAP_NAME_SHARED);
}

/* scary function - need rework. even in crossfire its changed now */
void monster_check_apply(object *mon, object *item)
{
    /* this function is simply to bad - for example will potions applied
     * not depending on the situation... why applying a heal potion when
     * full hp? firestorm potion when standing next to own people?
     * IF we do some AI stuff here like using items we must FIRST
     * add a AI - then doing the things. Think first, act later!
     */
}

/*
 * Mutually exclusive movement behaviours 
 */

void ai_stand_still(object *op, struct mob_behaviour_param *params, move_response *response)
{
    response->type = MOVE_RESPONSE_DIR;
    response->data.direction = 0;
}

void ai_sleep(object *op, struct mob_behaviour_param *params, move_response *response)
{
    if (QUERY_FLAG(op, FLAG_SLEEP))
    {
        if (op->enemy)
            CLEAR_FLAG(op, FLAG_SLEEP);
        else
        {
            response->type = MOVE_RESPONSE_DIR;
            response->data.direction = 0;
        }
    }
}

void ai_move_randomly(object *op, struct mob_behaviour_param *params, move_response *response)
{
    int     i, r;
    object *base    = find_base_info_object(op);

    /* Give up to 8 chances for a monster to move randomly */
    for (i = 0; i < 8; i++)
    {
        r = RANDOM() % 8 + 1;

        /* TODO: doesn't handle map borders */
        /* check x and y direction of possible move */
        if (params[AIPARAM_MOVE_RANDOMLY_XLIMIT].flags & AI_PARAM_PRESENT)
            if (abs(op->x + freearr_x[r] - base->x) > params[AIPARAM_MOVE_RANDOMLY_XLIMIT].intvalue)
                continue;
        if (params[AIPARAM_MOVE_RANDOMLY_YLIMIT].flags & AI_PARAM_PRESENT)
            if (abs(op->y + freearr_y[r] - base->y) > params[AIPARAM_MOVE_RANDOMLY_YLIMIT].intvalue)
                continue;

        if (!blocked_link(op, freearr_x[r], freearr_y[r]))
        {
            response->type = MOVE_RESPONSE_DIR;
            response->data.direction = r;
            return;
        }
    }
}

void ai_move_towards_home(object *op, struct mob_behaviour_param *params, move_response *response)
{
    /* TODO: optimization: pointer to the base ob in mob_data */
    object *base    = insert_base_info_object(op); 

    if (base && base->slaying)
    {
        /* If mob isn't already home */
        if (op->x != base->x || op->y != base->y || op->map->path != base->slaying)
        {
            mapstruct  *map = normalize_and_ready_map(op->map, &base->slaying);

            response->type = MOVE_RESPONSE_COORD;
            response->data.coord.x = base->x;
            response->data.coord.y = base->y;
            response->data.coord.map = map;
        }
    }
}

/* Useful if mob is much slower than enemy? */
void ai_step_back_after_swing(object *op, struct mob_behaviour_param *params, move_response *response)
{
    if (op->weapon_speed_left > 0 && OBJECT_VALID(op->enemy, op->enemy_count) && mob_can_see_obj(op, op->enemy,
                                                                                                 MOB_DATA(op)->enemy))
    {
        rv_vector  *rv  = get_known_obj_rv(op, MOB_DATA(op)->enemy, MAX_KNOWN_OBJ_RV_AGE);

        if (rv && rv->distance < (unsigned int) AIPARAM_INT(AIPARAM_KEEP_DISTANCE_TO_ENEMY_MIN_DIST))
        {
            response->type = MOVE_RESPONSE_DIR;
            response->data.direction = absdir(rv->direction + 4);
            op->anim_enemy_dir = response->data.direction;
        }
        else if (rv->distance == (unsigned int) AIPARAM_INT(AIPARAM_KEEP_DISTANCE_TO_ENEMY_MAX_DIST))
        {
            response->type = MOVE_RESPONSE_DIR;
            response->data.direction = 0;
            op->anim_enemy_dir = rv->direction;
        }
    }
}

void ai_avoid_line_of_fire(object *op, struct mob_behaviour_param *params, move_response *response)
{
    if (OBJECT_VALID(op->enemy, op->enemy_count))
    {
        /* TODO: not correct for multi-tile mobs, the in_line_of_fire() functions simply don't
         * work for them. Possible solutions: 1) disable for multi-tile mobs (what do big monsters care
         * about puny missiles, anyway?  2) fix the line-of-fire functions (can be very expensive) */
        /* Disabled for multi-tile mobs */
        if(op->more)
            return;
            
        /* TODO: mobs will not approach enemy through narrow corridors, as they can't 
         * avoid missiles there. It also means they can get stuck in the middle of a corridor as
         * a sitting duck for any distance attacks. Possible fixes: 1) only activate if the enemy if 
         * known to use missiles (maybe easy with upcoming mob damage memory) 2) temporarily disable 
         * if we get stuck somewhere. 3) detect getting stuck and either flee or charge.
         */
        
        /* Disable behaviour if we don't think enemy uses missiles */
        if(! QUERY_FLAG(MOB_DATA(op)->enemy, AI_OBJFLAG_USES_DISTANCE_ATTACK)) 
        {
            if(op->enemy->type == PLAYER) 
            {
                /* Nasty hack for quick detection of possible distance-attack
                 * skills */
                /* TODO: should preferably be using observed behaviour instead of
                 * chosen skill, but this is quite cheap. */
                char is_distance_skill[NROFSKILLS] = {
                    0,0,0,0,0, 0,0,0,0,0,
                    0,0,0,0,0, 0,0,0,1,0, /* Flame touch ? */
                    0,0,0,0,1, 1,1,0,0,1,
                    1,0,0,0,1, 1,0,0,0,0,
                    0,0 };
                    
                if(op->enemy->chosen_skill == NULL || 
                        ! is_distance_skill[op->enemy->chosen_skill->stats.sp])
                    return;
                SET_FLAG(MOB_DATA(op)->enemy, AI_OBJFLAG_USES_DISTANCE_ATTACK);
            } 
            else if (op->enemy->type == MONSTER) 
            {
                if(! QUERY_FLAG(op->enemy, FLAG_CAST_SPELL) &&
                        ! QUERY_FLAG(op->enemy, FLAG_READY_BOW)) 
                    return;
                SET_FLAG(MOB_DATA(op)->enemy, AI_OBJFLAG_USES_DISTANCE_ATTACK);
            }
        }
            
        /* Behaviour core */
        if(mob_can_see_obj(op, op->enemy, MOB_DATA(op)->enemy))
        {
            rv_vector  *rv  = get_known_obj_rv(op, MOB_DATA(op)->enemy, MAX_KNOWN_OBJ_RV_AGE);
        
            if (rv->distance > 2 && rv->distance < 8)        
            {
                int i;

                   /* Avoid staying in line of fire */
                if(can_hit_missile(op->enemy, op, rv, 1))
                       response->forbidden |= (1 << 0);

                for(i=-3; i<=3; i++) {
                    mapstruct *m;
                    int d = absdir(rv->direction + i);
                    int x = op->x + freearr_x[d];
                    int y = op->y + freearr_y[d];
            
                    /* Avoid moving into line of fire */
                    if ((m = out_of_map(op->map, &x, &y))) 
                    {
                        if(mapcoord_in_line_of_fire(op->enemy, m, x, y, 1))
                            response->forbidden |= (1 << d);
                    }
                }
            }
        }
    }
}

void ai_optimize_line_of_fire(object *op, struct mob_behaviour_param *params, move_response *response)
{
    /* TODO: not correct for multi-tile mobs, the in_line_of_fire() functions simply don't
     * work for them. Possible solutions: 1) disable for multi-tile mobs (what do big monsters care
     * about puny missiles, anyway?  2) fix the line-of-fire functions (can be very expensive) */
    /* Disabled for multi-tile mobs */
    if(op->more)
        return;
    
    if (OBJECT_VALID(op->enemy, op->enemy_count))
    {
        /* Behaviour core */
        if(mob_can_see_obj(op, op->enemy, MOB_DATA(op)->enemy))
        {
            int i;
            int good_directions = 0, ok_directions = 0;

            rv_vector  *rv  = get_known_obj_rv(op, MOB_DATA(op)->enemy, MAX_KNOWN_OBJ_RV_AGE);
            
            /* Too close or too far to care? */
            if(rv->distance <= 2 || rv->distance > 8)
                return;
            
            /* Already perfect? */
            if(can_hit_missile(op, op->enemy, rv, 1)) 
                good_directions = (1 << 0);
            else 
                response->forbidden |= (1 << 0); /* Don't stay in a bad spot */
            
            /* Find a nearby good spot */
            /* TODO: can probably be calculated instead of searched for */
            /* TODO: with this algorithm there is a certain state where
             * the mob starts zipping between two "half-good" spots */
            for(i=-2; i<=2; i++) 
            {
                mapstruct *m;
                int dir = absdir(rv->direction+i);
                int x = op->x + freearr_x[dir];
                int y = op->y + freearr_y[dir];

                /* Find a spot in or near line of fire, and forbid movements to other spots */
                if ((m = out_of_map(op->map, &x, &y))) 
                {
                    if(mapcoord_in_line_of_fire(op->enemy, m, x, y, 1)) /* good spot? */
                        good_directions |= (1 << dir);
                    else if(mapcoord_in_line_of_fire(op->enemy, m, x, y, 2)) /* ok spot? */
                        ok_directions |= (1 << dir);
                }
            }

            /* See if we have a movement response... */
            good_directions &= ~response->forbidden; 
            if(good_directions) {
                response->data.directions = good_directions;
                response->type = MOVE_RESPONSE_DIRS;
            }
            else {
                ok_directions &= ~response->forbidden; 
                if(ok_directions) {
                    response->data.directions = ok_directions;
                    response->type = MOVE_RESPONSE_DIRS;
                }
            }
        }
    }
}


void ai_move_towards_enemy(object *op, struct mob_behaviour_param *params, move_response *response)
{
    if (OBJECT_VALID(op->enemy, op->enemy_count) && mob_can_see_obj(op, op->enemy, MOB_DATA(op)->enemy))
    {
        rv_vector  *rv  = get_known_obj_rv(op, MOB_DATA(op)->enemy, MAX_KNOWN_OBJ_RV_AGE);
        /* TODO: if we can't see op->enemy, goto last known position, or something... ( or do nothing, and make that a separate behaviour ) */

        op->anim_enemy_dir = rv->direction;
        if (rv != NULL)
        {
            if (rv->distance > 1)
            {
                response->type = MOVE_RESPONSE_OBJECT;
                response->data.target.obj = op->enemy;
                response->data.target.obj_count = op->enemy_count;
            }
            else
            {
                /* Stay where we are */
                response->type = MOVE_RESPONSE_DIR;
                response->data.direction = 0;
            }
        }
    }
}

void ai_keep_distance_to_enemy(object *op, struct mob_behaviour_param *params, move_response *response)
{
    if (OBJECT_VALID(op->enemy, op->enemy_count) && mob_can_see_obj(op, op->enemy, MOB_DATA(op)->enemy))
    {
        rv_vector  *rv  = get_known_obj_rv(op, MOB_DATA(op)->enemy, MAX_KNOWN_OBJ_RV_AGE);

        if (rv)
        {
            /* keep distance is something different as run away.
             * But a endless "keep distance" is or at last looks the same.
             * So, we must avoid it.
             * With the "action movement delay, this should work very well.
             * We should also handle this more tricky in the AI behaviour itself.
             */
            if(rv->distance <= 1)
            {
                ai_move_towards_enemy(op, params, response);
                return;
            }
            
            if (rv->distance < (unsigned int) AIPARAM_INT(AIPARAM_KEEP_DISTANCE_TO_ENEMY_MIN_DIST))
            {
                response->type = MOVE_RESPONSE_DIR;
                response->data.direction = absdir(rv->direction + 4);
                op->anim_enemy_dir = response->data.direction;
            }
            else if (rv->distance < (unsigned int) AIPARAM_INT(AIPARAM_KEEP_DISTANCE_TO_ENEMY_MAX_DIST))
            {
//                response->type = MOVE_RESPONSE_DIR;
//                response->data.direction = 0;
                response->forbidden |= (1 << rv->direction);
                response->forbidden |= (1 << absdir(rv->direction+1));
                response->forbidden |= (1 << absdir(rv->direction-1));
                op->anim_enemy_dir = rv->direction;
            }
        }
    }
}

void ai_move_towards_enemy_last_known_pos(object *op, struct mob_behaviour_param *params, move_response *response)
{
    if (OBJECT_VALID(op->enemy, op->enemy_count) && MOB_DATA(op)->enemy->last_map)
    {
        rv_vector               rv;
        struct mob_known_obj   *enemy   = MOB_DATA(op)->enemy;
        mapstruct              *map     = ready_map_name(enemy->last_map, MAP_NAME_SHARED);

        if (get_rangevector_from_mapcoords(op->map, op->x, op->y, map, enemy->last_x, enemy->last_y, &rv,
                                           RV_EUCLIDIAN_DISTANCE))
        {
            op->anim_enemy_dir = rv.direction;
            if (rv.distance > 3)
            {
                response->type = MOVE_RESPONSE_COORD;
                response->data.coord.x = enemy->last_x;
                response->data.coord.y = enemy->last_y;
                response->data.coord.map = map;
            }
        }
    }
}

/* Stupid behaviour that moves around randomly looking for a lost enemy */
void ai_search_for_lost_enemy(object *op, struct mob_behaviour_param *params, move_response *response)
{
    if (OBJECT_VALID(op->enemy, op->enemy_count) && MOB_DATA(op)->enemy->last_map)
    {
        int i, r;

        /* Give up to 8 chances for a monster to move randomly */
        for (i = 0; i < 8; i++)
        {
            r = RANDOM() % 8 + 1;

            if (!blocked_link(op, freearr_x[r], freearr_y[r]))
            {
                response->type = MOVE_RESPONSE_DIR;
                response->data.direction = r;
                return;
            }
        }
    }
}

void ai_move_towards_waypoint(object *op, struct mob_behaviour_param *params, move_response *response)
{
    object     *wp;
    rv_vector   rv;
    int         try_next_wp = 0;

    wp = get_active_waypoint(op);
    if (wp)
    {
        mapstruct  *destmap = normalize_and_ready_map(op->map, &WP_MAP(wp));
        if (destmap)
        {
            /* We know which map we want to. Can we figure out where that
             * map lies relative to current position? */

            /* This rv may be computed several times, this is generally
             * not a performance problem, since the cache in the recursive
             * search usually catches that.
             * TODO: extend cache in recursive search with longer memory
             */
            if (!get_rangevector_from_mapcoords(op->map, op->x, op->y, destmap, WP_X(wp), WP_Y(wp), &rv,
                                                RV_RECURSIVE_SEARCH | RV_DIAGONAL_DISTANCE))
            {
                /* Problem: we couldn't find a relative direction between the
                 * maps. Usually it means that they are in different mapsets
                 * or too far away from each other. */
                LOG(llevDebug, "BUG: ai_move_towards_waypoint(): No connection between maps: '%s' and '%s'\n",
                    STRING_MAP_PATH(destmap), STRING_MAP_PATH(op->map));
                CLEAR_FLAG(wp, WP_FLAG_ACTIVE); /* disable this waypoint */
                try_next_wp = 1;
            }
            else
            {
                /* Good, we know general distance and direction to wp target */

                /* Are we close enough to accept the wp? */
                if (rv.distance <= (unsigned int) wp->stats.grace)
                {
                    /* Should we wait a little while? */
                    if (MOB_PATHDATA(op)->goal_delay_counter < WP_DELAYTIME(wp))
                    {
                        MOB_PATHDATA(op)->goal_delay_counter++;
                    }
                    else
                    {
#ifdef AI_DEBUG                     
                        LOG(llevDebug, "ai_move_towards_waypoint(): '%s' reached destination '%s'\n",
                            STRING_OBJ_NAME(op), STRING_OBJ_NAME(wp));
#endif

#ifdef PLUGINS
                        /* GROS: Handle for plugin trigger event */
                        if (wp->event_flags & EVENT_FLAG_TRIGGER)
                        {
                            CFParm  CFP;
                            CFParm *CFR;
                            int     k, l, m;
                            int     rtn_script  = 0;
                            object *event_obj   = get_event_object(wp, EVENT_TRIGGER);
                            m = 0;

                            k = EVENT_TRIGGER;
                            l = SCRIPT_FIX_NOTHING;
                            CFP.Value[0] = &k;
                            CFP.Value[1] = op;
                            CFP.Value[2] = wp;
                            CFP.Value[3] = NULL;
                            CFP.Value[4] = NULL;
                            CFP.Value[5] = &m;
                            CFP.Value[6] = &m;
                            CFP.Value[7] = &m;
                            CFP.Value[8] = &l;
                            CFP.Value[9] = (char *) event_obj->race;
                            CFP.Value[10] = (char *) event_obj->slaying;
                            if (findPlugin(event_obj->name) >= 0)
                            {
                                CFR = (PlugList[findPlugin(event_obj->name)].eventfunc) (&CFP);
                                rtn_script = *(int *) (CFR->Value[0]);
                                if (rtn_script != 0)
                                    return;
                            }
                        }
#endif

                        MOB_PATHDATA(op)->goal_delay_counter = 0;
                        MOB_PATHDATA(op)->best_distance = -1;
                        MOB_PATHDATA(op)->tried_steps = 0;
                        CLEAR_FLAG(wp, WP_FLAG_ACTIVE);
                        try_next_wp = 1;
                    }
                }
            }
        }
        else
        {
            LOG(llevDebug, "BUG: ai_move_towards_waypoint(): '%s' ('%s') no such map: '%s'\n", STRING_OBJ_NAME(op),
                STRING_OBJ_NAME(wp), STRING_WP_MAP(wp));
            CLEAR_FLAG(wp, WP_FLAG_ACTIVE);
            try_next_wp = 1;
        }
    }

    /* If we reached or gave up on the current waypoint */
    if (try_next_wp && wp)
    {
        if (WP_NEXTWP(wp) && (wp = find_waypoint(op, WP_NEXTWP(wp))))
        {
#ifdef AI_DEBUG                     
            LOG(llevDebug, "ai_move_towards_waypoint(): '%s' next WP: '%s'\n", STRING_OBJ_NAME(op), STRING_WP_NEXTWP(wp));
#endif
            SET_FLAG(wp, WP_FLAG_ACTIVE); /* activate new waypoint */
            MOB_PATHDATA(op)->best_distance = -1;
            MOB_PATHDATA(op)->tried_steps = 0;
        }
        else
        {
#ifdef AI_DEBUG                                 
            LOG(llevDebug, "ai_move_towards_waypoint(): '%s' no next WP\n", STRING_OBJ_NAME(op));
#endif
            wp = NULL;
        }
    }

    if (wp)
    {
        response->type = MOVE_RESPONSE_WAYPOINT;
        response->data.target.obj = wp;
        response->data.target.obj_count = wp->count;
    }
}

/* 
 * Runs away from enemy if scared
 * Sets scared if low hp
 * Clears scared if high enough hp OR after a random time
 */
void ai_run_away_from_enemy(object *op, struct mob_behaviour_param *params, move_response *response)
{
    rv_vector  *rv;

    /* Is scared? */
    if (QUERY_FLAG(op, FLAG_SCARED) && op->enemy)
    {
        if ((rv = get_known_obj_rv(op, MOB_DATA(op)->enemy, MAX_KNOWN_OBJ_RV_AGE)))
        {
            /* TODO: more intelligent: use pathfinding to find the
             * most distant point from enemy */
            response->type = MOVE_RESPONSE_DIR;
            response->data.direction = absdir(rv->direction + 4);
        }
        else
        {
            /* TODO: run around randomly? */
        }

        /* Regain senses? */
        if (op->stats.maxhp && AIPARAM_PRESENT(AIPARAM_RUN_AWAY_FROM_ENEMY_HP_THRESHOLD))
        {
            /* Gecko: I added a slight hysteresis treshold here 
             * (stay afraid until hp reaches 2*runaway % of maxhp) */
            if (op->stats.hp == op->stats.maxhp
             || (op->stats.hp * 100) / op->stats.maxhp > AIPARAM_INT(AIPARAM_RUN_AWAY_FROM_ENEMY_HP_THRESHOLD) * 2)
            {
                CLEAR_FLAG(op, FLAG_SCARED);
            }
        }
        else
        {
            /* If we aren't scared because of low hp, we can stop
             * being afraid after a random delay */
            if (!RANDOM() % 20)
                CLEAR_FLAG(op, FLAG_SCARED);
        }
    }
    else
    {
        /* Become scared? */
        if (op->stats.maxhp
         && AIPARAM_PRESENT(AIPARAM_RUN_AWAY_FROM_ENEMY_HP_THRESHOLD)
         && (op->stats.hp * 100) / op->stats.maxhp < AIPARAM_INT(AIPARAM_RUN_AWAY_FROM_ENEMY_HP_THRESHOLD))
        {
            SET_FLAG(op, FLAG_SCARED);
        }
    }
}

/* AI <-> plugin interface for movement behaviours */
void ai_plugin_move(object *op, struct mob_behaviour_param *params, move_response *response)
{
#ifdef PLUGINS
    CFParm  CFP;
    int     k, l, m;
    k = EVENT_AI_BEHAVIOUR;
    l = 0; /* SCRIPT_FIX_ALL; */ /* Script fix none */
    m = 0;
    CFP.Value[0] = &k;   /* Event type */
    CFP.Value[1] = NULL; /* Activator */
    CFP.Value[2] = op;   /* Me */
    CFP.Value[3] = NULL; /* Other */
    CFP.Value[4] = NULL; /* Message */
    CFP.Value[5] = &m;
    CFP.Value[6] = &m;
    CFP.Value[7] = &m;
    CFP.Value[8] = &l; /* Fix settings */
    CFP.Value[9] = (char *)AIPARAM_STRING(AIPARAM_PLUGIN_MOVE_BEHAVIOUR);  
    CFP.Value[10] = (char *)AIPARAM_STRING(AIPARAM_PLUGIN_MOVE_OPTIONS);
    CFP.Value[11] = (void *) response;
    PlugList[findPlugin(AIPARAM_STRING(AIPARAM_PLUGIN_MOVE_PLUGIN))].eventfunc (&CFP);
#endif 
}

/*
 * Misc behaviours
 */

/* Placeholder function for some special processes */
void ai_fake_process(object *op, struct mob_behaviour_param *params)
{
    LOG(llevBug, "BUG: ai_fake_process() should never be called\n");
}

void ai_look_for_other_mobs(object *op, struct mob_behaviour_param *params)
{
    /* TODO Very stupid solution for now: scan through all active and
     * check if we can reach them. Makes more sense when we have
     * per-map active lists. */

    /* TODO possibility for optimization: if we already have enemies there
     * is no need to look for new ones every timestep... */
    /* TODO: optimization: maybe first look through nearest tiles to see if something interesting is there,
     * then search the active list */
    object *obj;
    for (obj = active_objects; obj; obj = obj->active_next)
    {
        if ((QUERY_FLAG(obj, FLAG_ALIVE) || obj->type == PLAYER)
         && on_same_map(obj, op)
         && obj
         != op
         && mob_can_see_obj(op,
                            obj,
                            NULL))
        {
            /* TODO: get rid of double rv calculation 
             * (both can_see_obj() and register_npc_known_obj) 
             */
            register_npc_known_obj(op, obj, 0);
        }
    }
}

/* Calculate friendship level of each known mob */
void ai_friendship(object *op, struct mob_behaviour_param *params)
{
    struct mob_known_obj   *tmp;

    for (tmp = MOB_DATA(op)->known_mobs; tmp; tmp = tmp->next)
    {
        tmp->tmp_friendship = tmp->friendship;

        /* Replace with flexible behaviour parameters */
        if (is_enemy_of(op, tmp->obj))
            tmp->tmp_friendship += FRIENDSHIP_ATTACK;
        else if (is_friend_of(op, tmp->obj))
            tmp->tmp_friendship += FRIENDSHIP_HELP;

        /* Helps us focusing on a single enemy */
        if (tmp == MOB_DATA(op)->enemy)
            tmp->tmp_friendship += FRIENDSHIP_ENEMY_BONUS;

        /* Now factor in distance  */
        if (get_known_obj_rv(op, tmp, MAX_KNOWN_OBJ_RV_AGE))
        {
            tmp->tmp_friendship += (FRIENDSHIP_DIST_MAX / (int) MAX(tmp->rv.distance, 1.0)) * SGN(tmp->tmp_friendship);
        }
        /* TODO: test last_seen aging */
        //        tmp->tmp_friendship /= MAX(global_round_tag - tmp->last_seen, 1);
        //        LOG(llevDebug,"ai_friendship(): '%s' -> '%s'. friendship: %d\n",  STRING_OBJ_NAME(op), STRING_OBJ_NAME(tmp->obj), tmp->tmp_friendship);
    }
}

void ai_choose_enemy(object *op, struct mob_behaviour_param *params)
{
    object                 *oldenemy    = op->enemy;
    struct mob_known_obj   *tmp, *worst_enemy = NULL;

    /* Go through list of known mobs and choose the most hated
     * that we can get to.
     */
    for (tmp = MOB_DATA(op)->known_mobs; tmp; tmp = tmp->next)
    {
        if (tmp->tmp_friendship < 0)
        {
            /* Most hated enemy so far? */
            if ((worst_enemy == NULL || tmp->tmp_friendship < worst_enemy->tmp_friendship))
            {
                /* Ignore if we can't get to it at all */
                /* TODO: should probably use get_last_known_obj_rv() */
                rv_vector  *rv  = get_known_obj_rv(op, tmp, MAX_KNOWN_OBJ_RV_AGE);
                if (rv)
                {
                    op->anim_enemy_dir = rv->direction;
                    worst_enemy = tmp;
                }
            }
        }
    }

    /* Did we find an enemy? */
    if (worst_enemy)
    {
        //        LOG(llevDebug,"ai_choose_enemy(): %s's worst enemy is '%s', friendship: %d\n", STRING_OBJ_NAME(op), STRING_OBJ_NAME(worst_enemy->ob), worst_enemy->tmp_friendship);
        op->enemy = worst_enemy->obj;
        MOB_DATA(op)->enemy = worst_enemy;
        op->enemy_count = worst_enemy->obj_count;
    }
    else
    {
        op->enemy = NULL;
        MOB_DATA(op)->enemy = NULL;
    }

    /* Handle enemy switching (growl, speed up/down) */
    /* TODO: separate into another behaviour... */
    if (op->enemy != oldenemy)
    {
        if (op->enemy)
        {
            op->last_eat = 0;   /* important: thats our "we lose aggro count" - reset to zero here */
            if (!QUERY_FLAG(op, FLAG_FRIENDLY))
                play_sound_map(op->map, op->x, op->y, SOUND_GROWL, SOUND_NORMAL);

            /* The unaggressives look after themselves 8) */
            /* TODO: Make a separate behaviour... */
            //            if(QUERY_FLAG(op,FLAG_UNAGGRESSIVE)) {
            //                CLEAR_FLAG(op, FLAG_UNAGGRESSIVE);
            //            npc_call_for_help(op);
            //            }
        }
        set_mobile_speed(op, 0);
    }
}

/* AI <-> plugin interface for processes */
void ai_plugin_process(object *op, struct mob_behaviour_param *params)
{
#ifdef PLUGINS
    CFParm  CFP;
    int     k, l, m;
    k = EVENT_AI_BEHAVIOUR;
    l = 0; /* SCRIPT_FIX_ALL; */ /* Script fix none */
    m = 0;
    CFP.Value[0] = &k;   /* Event type */
    CFP.Value[1] = NULL; /* Activator */
    CFP.Value[2] = op;   /* Me */
    CFP.Value[3] = NULL; /* Other */
    CFP.Value[4] = NULL; /* Message */
    CFP.Value[5] = &m;
    CFP.Value[6] = &m;
    CFP.Value[7] = &m;
    CFP.Value[8] = &l; /* Fix settings */
    CFP.Value[9] = (char *)AIPARAM_STRING(AIPARAM_PLUGIN_PROCESS_BEHAVIOUR);   /* file */
    CFP.Value[10] = (char *)AIPARAM_STRING(AIPARAM_PLUGIN_PROCESS_OPTIONS);
    CFP.Value[11] = NULL;
    PlugList[findPlugin(AIPARAM_STRING(AIPARAM_PLUGIN_PROCESS_PLUGIN))].eventfunc (&CFP);
#endif 
}

/*
 * Attack behaviours
 */
int ai_melee_attack_enemy(object *op, struct mob_behaviour_param *params)
{
    rv_vector  *rv;

    if (QUERY_FLAG(op, FLAG_UNAGGRESSIVE)
     || QUERY_FLAG(op, FLAG_SCARED)
     || !OBJECT_VALID(op->enemy, op->enemy_count)
     || op->weapon_speed_left > 0)
        return FALSE;

    /* TODO: choose another enemy if this fails */
    if (!(rv = get_known_obj_rv(op, MOB_DATA(op)->enemy, MAX_KNOWN_OBJ_RV_AGE)))
        return FALSE;
    if (!can_hit_melee(rv->part, op->enemy, rv) || !mob_can_see_obj(op, op->enemy, MOB_DATA(op)->enemy))
        return FALSE;

    //    LOG(llevDebug,"ai_melee_attack_enemy(): '%s' -> '%s'\n", STRING_OBJ_NAME(op), STRING_OBJ_NAME(op->enemy));

    /* TODO: the following test should be done in skill_attack! */
    /* TODO: what if wc underflows? */
    op->anim_enemy_dir = rv->direction;
    if (QUERY_FLAG(op, FLAG_RUN_AWAY))
        rv->part->stats.wc -= 10;
    skill_attack(op->enemy, rv->part, 0, NULL);
    op->weapon_speed_left += FABS((int) op->weapon_speed_left) + 1;
    if (QUERY_FLAG(op, FLAG_RUN_AWAY))
        rv->part->stats.wc += 10;

    return TRUE;
}

int ai_bow_attack_enemy(object *op, struct mob_behaviour_param *params)
{
    object*bow =    NULL, *arrow = NULL, *target = op->enemy;
    rv_vector      *rv;
    int             tag;
    int             direction;

    if (!QUERY_FLAG(op, FLAG_READY_BOW)
     || QUERY_FLAG(op, FLAG_UNAGGRESSIVE)
     || QUERY_FLAG(op, FLAG_SCARED)
     || !OBJECT_VALID(op->enemy,
                      op->enemy_count)
     || op->weapon_speed_left > 0)
        return FALSE;

    /* TODO: choose another target if this or next test fails */
    if (!(rv = get_known_obj_rv(op, MOB_DATA(op)->enemy, MAX_KNOWN_OBJ_RV_AGE)))
        return FALSE;
    /* TODO: also check distance and LOS */
    if (!can_hit_missile(op, target, rv, 2) || !mob_can_see_obj(op, target, MOB_DATA(op)->enemy))
        return FALSE;

    //    LOG(llevDebug,"ai_distance_attack_enemy(): '%s' -> '%s'\n", STRING_OBJ_NAME(op), STRING_OBJ_NAME(op->enemy));

    op->anim_enemy_dir = rv->direction;
    direction = rv->direction;
    if (QUERY_FLAG(op, FLAG_CONFUSED))
        direction = absdir(direction + RANDOM() % 5 - 2);

    /* Find the applied bow */
    for (bow = op->inv; bow != NULL; bow = bow->below)
        if (bow->type == BOW && QUERY_FLAG(bow, FLAG_APPLIED))
            break;

    if (bow == NULL)
    {
        LOG(llevBug, "BUG: Monster %s (%d) has READY_BOW without bow.\n", STRING_OBJ_NAME(op), op->count);
        CLEAR_FLAG(op, FLAG_READY_BOW);
        return 0;
    }

    /* Select suitable arrows */
    if ((arrow = find_arrow(op, bow->race)) == NULL)
    {
        /* Out of arrows */
        manual_apply(op, bow, 0);
        CLEAR_FLAG(op, FLAG_READY_BOW);
        return 0;
    }

    /* thats a infinitve arrow! dupe it. */
    if (QUERY_FLAG(arrow, FLAG_SYS_OBJECT))
    {
        object *new_arrow   = get_object();
        copy_object(arrow, new_arrow);
        CLEAR_FLAG(new_arrow, FLAG_SYS_OBJECT);
        new_arrow->nrof = 0;

        /* now setup the self destruction */
        new_arrow->stats.food = 20;
        arrow = new_arrow;
    }
    else
        arrow = get_split_ob(arrow, 1);

    /* ugly nasty arrow-setting-upping block */
    set_owner(arrow, op);
    arrow->direction = direction;
    arrow->x = rv->part->x,arrow->y = rv->part->y;
    arrow->speed = 1;
    update_ob_speed(arrow);
    arrow->speed_left = 0;
    SET_ANIMATION(arrow, (NUM_ANIMATIONS(arrow) / NUM_FACINGS(arrow)) * rv->direction);
    arrow->level = op->level;
    arrow->last_heal = arrow->stats.wc; /* save original wc and dam */
    arrow->stats.hp = arrow->stats.dam; 
    arrow->stats.dam += bow->stats.dam + bow->magic + arrow->magic; /* NO_STRENGTH */
    arrow->stats.dam = FABS((int) ((float) (arrow->stats.dam * lev_damage[op->level])));
    arrow->stats.wc = 10 + (bow->magic + bow->stats.wc + arrow->magic + arrow->stats.wc + op->level);
    arrow->stats.wc_range = bow->stats.wc_range;
    arrow->map = op->map;
    arrow->last_sp = 12; /* we use fixed value for mobs */
    SET_FLAG(arrow, FLAG_FLYING);
    SET_FLAG(arrow, FLAG_IS_MISSILE);
    SET_FLAG(arrow, FLAG_FLY_ON);
    SET_FLAG(arrow, FLAG_WALK_ON);
    tag = arrow->count;
    arrow->stats.grace = arrow->last_sp;
    arrow->stats.maxgrace = 60 + (RANDOM() % 12);

    if (insert_ob_in_map(arrow, op->map, op, 0))
    {
        play_sound_map(arrow->map, arrow->x, arrow->y, SOUND_THROW, SOUND_NORMAL);
        move_arrow(arrow);
    }

    op->weapon_speed_left += FABS((int) op->weapon_speed_left) + 1;

    /* hack: without this, a monster with a bow is invinsible by a non range monster
     * with same speed. It simply runs away, can't be catched but will range kill
     * the other. Thats not what we want.
     * To remove this speed thingy, we need a flag for the AI which skips the movement
     * phase after a cast/arrow action.
     * At last we must skip a action which brings the mob out of range ... so, a movement
     * to the enemy should be allowed. This is not a question of reality of not - this will
     * destroy not only game play but also every map design and is a critical misbehaviour.
     */
    op->speed_left--;
    return 1;
}

#define MAX_KNOWN_SPELLS 20

/* TODO: slightly rework this */
object * monster_choose_random_spell(object *monster)
{
    object *altern[MAX_KNOWN_SPELLS];
    object *tmp;
    spell  *spell;
    int     i = 0, j;

    for (tmp = monster->inv; tmp != NULL; tmp = tmp->below)
        if (tmp->type == ABILITY || tmp->type == SPELLBOOK)
        {
            /*  Check and see if it's actually a useful spell */
            if ((spell = find_spell(tmp->stats.sp)) != NULL
             && !(spell->path & (PATH_INFO | PATH_TRANSMUTE | PATH_TRANSFER | PATH_LIGHT)))
            {
                if (tmp->stats.maxsp)
                    for (j = 0; i < MAX_KNOWN_SPELLS && j < tmp->stats.maxsp; j++)
                        altern[i++] = tmp;
                else
                    altern[i++] = tmp;
                if (i == MAX_KNOWN_SPELLS)
                    break;
            }
        }

    if (!i)
        return NULL;

    return altern[RANDOM() % i];
}

int ai_spell_attack_enemy(object *op, struct mob_behaviour_param *params)
{
    object     *target  = op->enemy;
    rv_vector  *rv;
    spell      *sp;
    object     *spell_item;
    int         sp_type, ability, direction, sp_cost;

    if (QUERY_FLAG(op, FLAG_UNAGGRESSIVE)
     || QUERY_FLAG(op, FLAG_SCARED)
     || !QUERY_FLAG(op, FLAG_CAST_SPELL)
     || !OBJECT_VALID(op->enemy,
                      op->enemy_count)
     || op->weapon_speed_left > 0
     || op->last_grace > 0)
        return FALSE;

    /* TODO: choose another target if this or next test fails */
    if (!(rv = get_known_obj_rv(op, MOB_DATA(op)->enemy, MAX_KNOWN_OBJ_RV_AGE)))
        return FALSE;
    /* TODO: also check distance and LOS */
    /* TODO: should really check type of spell (area or missile) */
    if (!can_hit_missile(op, target, rv, 2) || !mob_can_see_obj(op, op->enemy, MOB_DATA(op)->enemy))
        return FALSE;

    //    LOG(llevDebug,"ai_distance_attack_enemy(): '%s' -> '%s'\n", STRING_OBJ_NAME(op), STRING_OBJ_NAME(op->enemy));

    op->anim_enemy_dir = rv->direction;
    direction = rv->direction;
    if (QUERY_FLAG(op, FLAG_CONFUSED))
        direction = absdir(direction + RANDOM() % 5 - 2);

    /* Find a reasonable spell  */
    if ((spell_item = monster_choose_random_spell(op)) == NULL)
    {
        LOG(llevDebug, "ai_spell_attack_enemy() No spell found! Turned off spells in %s (%s) (%d,%d)\n",
            STRING_OBJ_NAME(op), STRING_MAP_NAME(op->map), op->x, op->y);
        CLEAR_FLAG(op, FLAG_CAST_SPELL); /* Will be turned on when picking up book */
        return 0;
    }

    if (spell_item->stats.hp)
    {
        /* Alternate long-range spell: check how far away enemy is */
        if (rv->distance > 6)
            sp_type = spell_item->stats.hp;
        else
            sp_type = spell_item->stats.sp;
    }
    else
        sp_type = spell_item->stats.sp;

    if ((sp = find_spell(sp_type)) == NULL)
    {
        LOG(llevDebug, "ai_spell_attack_enemy(): Can't find spell #%d for mob %s (%s) (%d,%d)\n", sp_type,
            STRING_OBJ_NAME(op), STRING_MAP_NAME(op->map), op->x, op->y);
        return 0;
    }

    sp_cost = SP_level_spellpoint_cost(op, op, sp_type);
    if (op->stats.sp < sp_cost)
        return FALSE;

    /* TODO: this kind of spells shouldn't be handled here... */
    if (sp->flags & SPELL_DESC_SELF) /* Spell should be cast on caster (ie, heal, strength) */
        direction = 0;

    ability = (spell_item->type == ABILITY && QUERY_FLAG(spell_item, FLAG_IS_MAGICAL));

    /* If we cast a spell, only use up casting_time speed */
    op->speed_left += (float) 1.0 - (float) spells[sp_type].time / (float) 20.0 * (float) FABS(op->speed); 

    op->stats.sp -= sp_cost;

    /* add default cast time from spell force to monster */
    /* TODO: what is this? */
    op->last_grace += spell_item->last_grace;

    /*LOG(-1,"CAST2: dir:%d (%d)- target:%s\n", dir, rv->direction, query_name(op->enemy) );*/
    /* TODO: what does the return value of cast_spell do ? */
    cast_spell(rv->part, rv->part, direction, sp_type, ability, spellNormal, NULL);

    op->speed_left--;/* hack: see bow bahaviour! */    
    return TRUE;
}

/* AI <-> plugin interface for actions */
int ai_plugin_action(object *op, struct mob_behaviour_param *params)
{
    int ret = 0;
#ifdef PLUGINS
    CFParm  CFP, * retCFP;
    int     k, l, m;
    k = EVENT_AI_BEHAVIOUR;
    l = 0; /* SCRIPT_FIX_ALL; */ /* Script fix none */
    m = 0;
    CFP.Value[0] = &k;   /* Event type */
    CFP.Value[1] = NULL; /* Activator */
    CFP.Value[2] = op;   /* Me */
    CFP.Value[3] = NULL; /* Other */
    CFP.Value[4] = NULL; /* Message */
    CFP.Value[5] = &m;
    CFP.Value[6] = &m;
    CFP.Value[7] = &m;
    CFP.Value[8] = &l; /* Fix settings */
    CFP.Value[9] = (char *) AIPARAM_STRING(AIPARAM_PLUGIN_PROCESS_BEHAVIOUR);   /* file */
    CFP.Value[10] = (char *) AIPARAM_STRING(AIPARAM_PLUGIN_PROCESS_OPTIONS);
    CFP.Value[11] = NULL;
    retCFP = PlugList[findPlugin(AIPARAM_STRING(AIPARAM_PLUGIN_PROCESS_PLUGIN))].eventfunc (&CFP);
    ret = *(int *)retCFP->Value[0];
#endif 

    return ret;
}
/*
 * Support functions for move_monster()
 */

static inline void regenerate_stats(object *op)
{
    /* (Not really a behaviour, but we keep it here anyway... ) */

    /*  generate hp, if applicable */
    if (op->stats.Con && op->stats.hp < op->stats.maxhp)
    {
        if (++op->last_heal > 5)
        {
            op->last_heal = 0;
            op->stats.hp += op->stats.Con;

            if (op->stats.hp > op->stats.maxhp)
                op->stats.hp = op->stats.maxhp;
        }

        /* So if the monster has gained enough HP that they are no longer afraid */
        /* TODO: should be handled elsewhere */
        if (QUERY_FLAG(op, FLAG_RUN_AWAY)
         && op->stats.hp >= (signed short) (((float) op->run_away / (float) 100) * (float) op->stats.maxhp))
            CLEAR_FLAG(op, FLAG_RUN_AWAY);
    }

    /* generate sp, if applicable */
    if (op->stats.Pow && op->stats.sp < op->stats.maxsp)
    {
        op->last_sp += (int) ((float) (8 * op->stats.Pow) / FABS(op->speed));
        op->stats.sp += op->last_sp / 128;  /* causes Pow/16 sp/tick */
        op->last_sp %= 128;
        if (op->stats.sp > op->stats.maxsp)
            op->stats.sp = op->stats.maxsp;
    }

    /* I think this is spell casting delay... */
    if (op->last_grace)
        op->last_grace--;
}

/* Get a direction from object op to object target, using precomputed paths
 * if available, and request path finding if needed */
static int calc_direction_towards(object *op, object *target, mapstruct *map, int x, int y)
{
    struct mobdata_pathfinding *pf;
    mapstruct                  *path_map;
    rv_vector                   target_rv, segment_rv;

    target_rv.direction = 1234543;
    segment_rv.direction = 1234542;

    pf = MOB_PATHDATA(op);

    if (map == NULL)
    {
        LOG(llevBug, "BUG: invalid destination map for '%s'\n", STRING_OBJ_NAME(op)); 
        return 0;
    }

    /* Get general direction and distance to target */
    get_rangevector_from_mapcoords(op->map, op->x, op->y, map, x, y, &target_rv,
                                   RV_RECURSIVE_SEARCH | RV_DIAGONAL_DISTANCE);
    /* TODO: verify results */
    /* if not on same map (or close) do something else... */

    /* Close enough already? */
    if (target_rv.distance <= 1)
    {
        if (target_rv.distance == 0)
            return 0;
        else
            return target_rv.direction;
    }

    /* Clean up old path */
    if (pf->path)
    {
        if (pf->target_obj != target
         || (target && pf->target_count != target->count)
         || (!target && (pf->target_map != map->path || pf->target_x != x || pf->target_y != y)))
        {
            free_path(pf->path);
            pf->path = NULL;
        }
    }

    /* No precomputed path (yet) ? */
    if (pf->path == NULL)
    {
        /* request new path */
        if (!pf->path_requested)
        {
            pf->target_obj = target;
            if (target)
            {
                pf->target_count = target->count;
                FREE_AND_CLEAR_HASH(pf->target_map);
            }
            else
            {
                FREE_AND_ADD_REF_HASH(pf->target_map, map->path);
                pf->target_x = x;
                pf->target_y = y;
            }

#ifdef DEBUG_PATHFINDING
            LOG(llevDebug, "calc_direction_towards() path=NULL '%s'->'%s'\n", STRING_OBJ_NAME(op),
                STRING_OBJ_NAME(target));
#endif
            request_new_path(op);
        }

        /* Take a first guesstimate step */
        return target_rv.direction;
    } 

    path_map = ready_map_name(pf->path->map, MAP_NAME_SHARED);
    /* Walk towards next precomputed coordinate */
    get_rangevector_from_mapcoords(op->map, op->x, op->y, path_map, pf->path->x, pf->path->y, &segment_rv,
                                   RV_RECURSIVE_SEARCH | RV_DIAGONAL_DISTANCE);
    /* TODO check result */

    /* throw away segment if we are finished with it */
    if (segment_rv.distance <= 1 && pf->path != NULL)
    {
        return_poolchunk(pf->path, pool_path_segment);
        pf->path = pf->path->next; /* assuming poolchunk is still valid */
        pf->tried_steps = 0;
        pf->best_distance = -1;
    }

    if ((int) segment_rv.distance < pf->best_distance || pf->best_distance == -1)
    {
        /* If we got closer: store closest distance & reset timeout */
        pf->best_distance = segment_rv.distance;
        pf->tried_steps = 0;
    }
    else if (pf->tried_steps++ > WP_MOVE_TRIES)
    {
        /* If not got closer for a while: ask for a new path */
        pf->target_obj = target;
        if (target)
        {
            FREE_AND_CLEAR_HASH(pf->target_map);
            pf->target_count = target->count;
        }
        else
        {
            FREE_AND_ADD_REF_HASH(pf->target_map, map->path);
            pf->target_x = x;
            pf->target_y = y;
        }
        if (!pf->path_requested)
        {
#ifdef DEBUG_PATHFINDING
            LOG(llevDebug, "calc_direction_towards() timeout '%s'->'%s'\n", STRING_OBJ_NAME(op), STRING_OBJ_NAME(target));
#endif
            request_new_path(op);
        }
    }

    return segment_rv.direction;
}

static int calc_direction_towards_coord(object *op, mapstruct *map, int x, int y)
{
    return calc_direction_towards(op, NULL, map, x, y);
}

static int calc_direction_towards_object(object *op, object *target)
{
    /* Request new path if target has moved too much */
    if (MOB_PATHDATA(op)->path
     && MOB_PATHDATA(op)->goal_map
     && (target->map->path != MOB_PATHDATA(op)->goal_map
      || target->x != MOB_PATHDATA(op)->goal_x
      || target->y != MOB_PATHDATA(op)->goal_y))
    {
        rv_vector   rv_goal, rv_target;
        mapstruct  *goal_map    = ready_map_name(MOB_PATHDATA(op)->goal_map, MAP_NAME_SHARED);

        if (!goal_map)
        {
            LOG(llevDebug, "BUGBUG: calc_direction_towards_object(): goal_map == NULL (%s <->%s)\n",
                STRING_OBJ_NAME(op), STRING_OBJ_NAME(target));
            return 0;
        }

        /* TODO if we can't see the object, goto its last known position
         * (also have to separate between well-known objects that we can find
         * without seeing, and other objects that we have to search or track */
        /* TODO make sure maps are loaded (here and everywhere else) */
        if (get_rangevector_from_mapcoords(target->map, target->x, target->y, goal_map, MOB_PATHDATA(op)->goal_x,
                                           MOB_PATHDATA(op)->goal_y, &rv_goal, RV_DIAGONAL_DISTANCE)
         && get_rangevector_from_mapcoords(op->map,
                                           op->x,
                                           op->y,
                                           target->map,
                                           target->x,
                                           target->y,
                                           &rv_target,
                                           RV_DIAGONAL_DISTANCE))
        {
            /* Heuristic: if dist(target, path goal) > dist(target, self) 
             * then get a new path */
            if (rv_target.distance > 1 && rv_goal.distance * 2 > rv_target.distance)
            {
#ifdef DEBUG_PATHFINDING
                LOG(llevDebug, "calc_direction_towards_object(): %s's target '%s' has moved\n", STRING_OBJ_NAME(op),
                    STRING_OBJ_NAME(target));
#endif
                free_path(MOB_PATHDATA(op)->path);
                MOB_PATHDATA(op)->path = NULL;
            }
        }
    }

    return calc_direction_towards(op, target, target->map, target->x, target->y);
}

/* Get a direction towards the target stored in the waypoint object wp
 * tries to use precomputed path if available or request path finding if needed */
static int calc_direction_towards_waypoint(object *op, object *wp)
{
    return calc_direction_towards(op, wp, normalize_and_ready_map(op->map, &WP_MAP(wp)), WP_X(wp), WP_Y(wp));
}

/* Actually move the monster in the specified direction. If there is something blocking,
 * try to go on either side of it */
static int do_move_monster(object *op, int dir, uint16 forbidden)
{
    int m;

    /* Confused monsters need a small adjustment */
    if (QUERY_FLAG(op, FLAG_CONFUSED)) {
        dir = absdir(dir + RANDOM() % 3 + RANDOM() % 3 - 2);
        forbidden = 0;
    }

    if (!(forbidden & (1 << dir)) && move_object(op, dir)) /* Can the monster move directly toward waypoint? */
        return TRUE;

    m = 1 - (RANDOM() & 2);          /* Try left or right first? */
    /* try different detours */
    if ((!(forbidden & (1 << absdir(dir + m))) && move_object(op, absdir(dir + m)))
     || (!(forbidden & (1 << absdir(dir - m))) && move_object(op, absdir(dir - m)))
     || (!(forbidden & (1 << absdir(dir + m * 2))) && move_object(op, absdir(dir + m * 2)))
     || (!(forbidden & (1 << absdir(dir - m * 2))) && move_object(op, absdir(dir - m * 2))))
        return TRUE;

    /* Couldn't move at all... */
    return FALSE;
}

/* Purge invalid and old mobs from list of known mobs */
static inline void cleanup_mob_knowns(struct mob_known_obj **first)
{
    struct mob_known_obj   *tmp;
    for (tmp = *first; tmp; tmp = tmp->next)
    {
        if (!OBJECT_VALID(tmp->obj, tmp->obj_count) || ROUND_TAG - tmp->last_seen > MAX_KNOWN_OBJ_AGE)
        {
            if (tmp->next)
                tmp->next->prev = tmp->prev;

            if (tmp->prev)
                tmp->prev->next = tmp->next;
            else
                *first = tmp->next;

            return_poolchunk(tmp, pool_mob_knownobj);
        }
    }
}

int choose_direction_from_bitmap(object *op, int bitmap)
{
    int numdirs=0, dirs[9], i;

    for(i=0; i<9; i++) 
    {
        if(bitmap & (1 << i)) 
        {
            dirs[numdirs] = i;
            numdirs++;
        }
    }
    
    if(numdirs == 0) 
        return 0;

    return dirs[RANDOM()%(numdirs)];
}

/* Calculate a movement direction given a movement response */
static inline int direction_from_response(object *op, move_response *response)
{
    switch (response->type)
    {
        case MOVE_RESPONSE_DIR:
          return response->data.direction;
        case MOVE_RESPONSE_DIRS:
          return choose_direction_from_bitmap(op, response->data.directions);
        case MOVE_RESPONSE_OBJECT:
          //            LOG(llevDebug,"dir_from_response(): '%s' -> '%s'\n", STRING_OBJ_NAME(op), STRING_OBJ_NAME(response.data.target.obj));
          return calc_direction_towards_object(op, response->data.target.obj);
        case MOVE_RESPONSE_WAYPOINT:
          //            LOG(llevDebug,"dir_from_response(): '%s' -> '%s'\n", STRING_OBJ_NAME(op), STRING_OBJ_NAME(response.data.target.obj));
          return calc_direction_towards_waypoint(op, response->data.target.obj);
        case MOVE_RESPONSE_COORD:
          //            LOG(llevDebug,"dir_from_response(): '%s' -> '%s'\n", STRING_OBJ_NAME(op), STRING_OBJ_NAME(response.data.target.obj));
          return calc_direction_towards_coord(op, response->data.coord.map, response->data.coord.x,
                                              response->data.coord.y);

        default:
          return 0;
    }
}

/*
 * Main AI function
 */

/* Move-monster returns 1 if the object has been freed, otherwise 0.  */
int move_monster(object *op)
{
    move_response           response;
    int                     dir, tmp_dir;
    int                     success;
    struct mob_behaviour   *behaviour;

    if (op == NULL || op->type != MONSTER)
    {
        LOG(llevDebug, "move_monster(): Called for non-monster object '%s'\n", STRING_OBJ_NAME(op));
        return 0;
    }

    /*
     * First, some general monster-management
     */      

    tmp_dir = op->anim_enemy_dir;
    op->anim_enemy_dir = -1;      /* control the facings 25 animations */
    op->anim_moving_dir = -1;     /* the same for movement */

    /* Set up mob data if missing */
    if (MOB_DATA(op) == NULL)
    {
        op->custom_attrset = get_poolchunk(pool_mob_data);
        MOB_DATA(op)->behaviours = setup_behaviours(op);
    }

    /* Purge invalid and old mobs from list of known mobs */
    cleanup_mob_knowns(&MOB_DATA(op)->known_mobs);
    cleanup_mob_knowns(&MOB_DATA(op)->known_objs);

    regenerate_stats(op); /* Regenerate if applicable */

    /*
     * Internal thought and sensing behaviours
     * All of those are always executed     
     */
    for (behaviour = MOB_DATA(op)->behaviours->behaviours[BEHAVIOURCLASS_PROCESSES];
         behaviour != NULL;
         behaviour = behaviour->next)
    {
        /* TODO: find a slightly more efficient way of handling 
         * non-executable "fake" processes */
        if(behaviour->declaration->func != ai_fake_process)
            ((void(*) (object *, struct mob_behaviour_param *)) behaviour->declaration->func) (op, behaviour->parameters);
    }

    /*
     * Normal-priority movement behaviours. The first to return
     * a movement disables the rest
     */
    response.type = MOVE_RESPONSE_NONE; /* Clear the movement response */
    response.forbidden = 0;

    for (behaviour = MOB_DATA(op)->behaviours->behaviours[BEHAVIOURCLASS_MOVES];
         behaviour != NULL;
         behaviour = behaviour->next)
    {
        ((void(*) (object *, struct mob_behaviour_param *, move_response *)) behaviour->declaration->func)
        (op, behaviour->parameters, & response);
        if (response.type != MOVE_RESPONSE_NONE)
            break;
    }

    /* TODO move_home alternative: move_towards_friend */

    /* TODO make it possible to move _away_ from waypoint or object */

    /* Calculate direction from response needed and execute movement */
    dir = direction_from_response(op, &response);
    if (dir > 0)
    {
        success = do_move_monster(op, dir, response.forbidden);
        /* TODO: handle success=0 and precomputed paths/giving up */
    }
    
    /* Try to avoid standing still if we aren't allowed to */
    if((dir == 0 || success == 0) && (response.forbidden & (1 << 0))) {
        success = do_move_monster(op, (RANDOM()%8)+1, response.forbidden);
    }

    /* 
     * Other mutually exclusive action commands
     * First to return TRUE disables the rest
     * TODO: some monsters can do multiple attacks? make the number of iterations here a parameter
     * TODO: either shuffle these randomly or use some sort of priority system
     * TODO: maybe separate into two parts: decision (gives an action and a priority) and
     *       execution (which done on the highest-prioritized action after all decisions are finished)
     * TODO: in original rules DEX has influence over whether to try any of these or not 
     */
    for (behaviour = MOB_DATA(op)->behaviours->behaviours[BEHAVIOURCLASS_ACTIONS];
         behaviour != NULL;
         behaviour = behaviour->next)
    {
        if (((int(*) (object *, struct mob_behaviour_param *)) behaviour->declaration->func) (op, behaviour->parameters))
            break;
    }

    return 0;
}

/*
 * Pathfinding "callback"
 */

/* A request for path finding has been accepted and we must now find out 
 *   1) where we actually wanted to go, and
 *   2) how to get there.
 */
void object_accept_path(object *op)
{
    mapstruct  *goal_map;
    int         goal_x, goal_y;
    path_node  *path;
    object     *target;

    /* make sure we have a valid target obj or map */
    if (op->type != MONSTER
     || MOB_DATA(op) == NULL
     || (!OBJECT_VALID(MOB_PATHDATA(op)->target_obj, MOB_PATHDATA(op)->target_count) && !MOB_PATHDATA(op)->target_map))
        return;

    /* 1: Where do we want to go? */
    target = MOB_PATHDATA(op)->target_obj;

    /* Is target our real target, is it a waypoint which stores the target 
     * coords? Or is our target a coordinate in the target_* values? */
    if (target == NULL)
    {
        /* Move towards a spcific coordinate */
        goal_x = MOB_PATHDATA(op)->target_x;
        goal_y = MOB_PATHDATA(op)->target_y;
        goal_map = normalize_and_ready_map(op->map, &MOB_PATHDATA(op)->target_map);
    }
    else if (target->type == TYPE_WAYPOINT_OBJECT)
    {
        /* Default map is current map */
        goal_x = WP_X(target);
        goal_y = WP_Y(target);
        goal_map = normalize_and_ready_map(op->map, &WP_MAP(target));

        FREE_AND_CLEAR_HASH(MOB_PATHDATA(op)->goal_map);
    }
    else
    {
        goal_x = target->x;
        goal_y = target->y;
        if (target->type == TYPE_BASE_INFO)
        {
            goal_map = normalize_and_ready_map(op->map, &target->slaying);
            LOG(llevDebug, "source: %s, map %s (%p), target %s map %s (%p)\n", op->name, op->map->path, op->map,
                target->name, goal_map->path, goal_map);
        }
        else
            goal_map = target->map;            

        /* Keep track of targets that may move */
        FREE_AND_ADD_REF_HASH(MOB_PATHDATA(op)->goal_map, goal_map->path);
        MOB_PATHDATA(op)->goal_x = goal_x;
        MOB_PATHDATA(op)->goal_y = goal_y;
    } 

    /* 2) Do the actual pathfinding: find a path, and compress it */
    path = compress_path(find_path(op, op->map, op->x, op->y, goal_map, goal_x, goal_y));

    if (path)
    {
        /* Skip the first path element (always the starting position) */
        path = path->next;
        if (!path)
        {
            /*            SET_FLAG(waypoint, FLAG_CONFUSED); */
            return;
        }

#ifdef DEBUG_PATHFINDING
        {
            path_node  *tmp;
            LOG(llevDebug, "object_accept_path(): '%s' new path -> '%s': ", STRING_OBJ_NAME(op),
                STRING_OBJ_NAME(MOB_PATHDATA(op)->target_obj));
            for (tmp = path; tmp; tmp = tmp->next)
                LOG(llevDebug, "(%d,%d) ", tmp->x, tmp->y);
            LOG(llevDebug, "\n");
        }
#endif        
        /* Free any old precomputed path */
        if (MOB_PATHDATA(op)->path)
            free_path(MOB_PATHDATA(op)->path);

        /* And store the new one */
        MOB_PATHDATA(op)->path = encode_path(path, NULL);

        /* Clear counters and stuff */
        MOB_PATHDATA(op)->best_distance = -1;
        MOB_PATHDATA(op)->tried_steps = 0;
    }
    else
        LOG(llevDebug, "object_accept_path(): no path to destination ('%s' -> '%s')\n", STRING_OBJ_NAME(op),
            STRING_OBJ_NAME(MOB_PATHDATA(op)->target_obj));
    /* TODO: handle the case where no path can be found */
}

/*
 * Non-scripted chat functions
 */

static void free_messages(msglang *msgs)
{
    int messages, keywords;

    if (!msgs)
        return;
    for (messages = 0; msgs->messages[messages]; messages++)
    {
        if (msgs->keywords[messages])
        {
            for (keywords = 0; msgs->keywords[messages][keywords]; keywords++)
                free(msgs->keywords[messages][keywords]);
            free(msgs->keywords[messages]);
        }
        free(msgs->messages[messages]);
    }
    free(msgs->messages);
    free(msgs->keywords);
    free(msgs);
}

static msglang * parse_message(const char *msg)
{
    msglang    *msgs;
    int         nrofmsgs, msgnr, i;
    char       *cp, *line, *last, *tmp;
    char       *buf = strdup_local(msg);

    /* First find out how many messages there are.  A @ for each. */
    for (nrofmsgs = 0, cp = buf; *cp; cp++)
        if (*cp == '@')
            nrofmsgs++;
    if (!nrofmsgs)
    {
        free(buf);
        return NULL;
    }

    msgs = (msglang *) malloc(sizeof(msglang));
    msgs->messages = (char * *) malloc(sizeof(char *) * (nrofmsgs + 1));
    msgs->keywords = (char * **) malloc(sizeof(char * *) * (nrofmsgs + 1));
    for (i = 0; i <= nrofmsgs; i++)
    {
        msgs->messages[i] = NULL;
        msgs->keywords[i] = NULL;
    }

    for (last = NULL, cp = buf, msgnr = 0; *cp; cp++)
        if (*cp == '@')
        {
            int nrofkeywords, keywordnr;
            *cp = '\0'; cp++;
            if (last != NULL)
            {
                msgs->messages[msgnr++] = strdup_local(last);
                tmp = msgs->messages[msgnr - 1];
                for (i = (int) strlen(tmp); i; i--)
                {
                    if (*(tmp + i) && *(tmp + i) != 0x0a && *(tmp + i) != 0x0d)
                        break;
                    *(tmp + i) = 0;
                }
            }
            if (strncmp(cp, "match", 5))
            {
                LOG(llevBug, "BUG: parse_message(): Unsupported command in message.\n");
                free(buf);
                return NULL;
            }
            for (line = cp + 6, nrofkeywords = 0; *line != '\n' && *line; line++)
                if (*line == '|')
                    nrofkeywords++;
            if (line > cp + 6)
                nrofkeywords++;
            if (nrofkeywords < 1)
            {
                LOG(llevBug, "BUG: parse_message():Too few keywords in message.\n");
                free(buf);
                free_messages(msgs);
                return NULL;
            }
            msgs->keywords[msgnr] = (char * *) malloc(sizeof(char * *) * (nrofkeywords + 1));
            msgs->keywords[msgnr][nrofkeywords] = NULL;
            last = cp + 6;
            cp = strchr(cp, '\n');
            if (cp != NULL)
                cp++;
            for (line = last, keywordnr = 0; line < cp && *line; line++)
                if (*line == '\n' || *line == '|')
                {
                    *line = '\0';
                    if (last != line)
                        msgs->keywords[msgnr][keywordnr++] = strdup_local(last);
                    else
                    {
                        if (keywordnr < nrofkeywords)
                        {
                            /* Whoops, Either got || or |\n in @match. Not good */
                            msgs->keywords[msgnr][keywordnr++] = strdup_local("xxxx");
                            /* We need to set the string to something sensible to    *
                                * prevent crashes later. Unfortunately, we can't set to *
                                * NULL, as that's used to terminate the for loop in     *
                                * talk_to_npc.  Using xxxx should also help map         *
                                * developers track down the problem cases.              */
                            LOG(llevBug, "BUG: parse_message(): Tried to set a zero length message in parse_message\n");
                            /* I think this is a error worth reporting at a reasonably *
                                * high level. When logging gets redone, this should       *
                                * be something like MAP_ERROR, or whatever gets put in    *
                                * place. */
                            if (keywordnr > 1)
                                           /* This is purely addtional information, should *
                                            * only be gieb if asked */
                                LOG(llevDebug, "Msgnr %d, after keyword %s\n", msgnr + 1,
                                    msgs->keywords[msgnr][keywordnr - 2]);
                            else
                                LOG(llevDebug, "Msgnr %d, first keyword\n", msgnr + 1);
                        }
                    }
                    last = line + 1;
                }
            /*
               * your eyes aren't decieving you, this is code repetition.  However,
               * the above code doesn't catch the case where line<cp going into the
               * for loop, skipping the above code completely, and leaving undefined
                    * data in the keywords array.  This patches it up and solves a crash
               * bug.  garbled 2001-10-20
               */
            if (keywordnr < nrofkeywords)
            {
                LOG(llevBug, "BUG: parse_message(): Map developer screwed up match statement" " in parse_message\n");
                if (keywordnr > 1)
                               /* This is purely addtional information, should *
                                * only be gieb if asked */
                    LOG(llevDebug, "Msgnr %d, after keyword %s\n", msgnr + 1, msgs->keywords[msgnr][keywordnr - 2]);
                else
                    LOG(llevDebug, "Msgnr %d, first keyword\n", msgnr + 1);
#if 0
/* Removed this block - according to the compiler, this has no effect,
 * and looking at the if statement above, the certainly appears to be the
 * case.
 */
          for(keywordnr; keywordnr <= nrofkeywords; keywordnr++)
              msgs->keywords[msgnr][keywordnr] = strdup_local("xxxx");
#endif
            }
            last = cp;
        }
    if (last != NULL)
        msgs->messages[msgnr++] = strdup_local(last);

    tmp = msgs->messages[msgnr - 1];
    for (i = (int) strlen(tmp); i; i--)
    {
        if (*(tmp + i) && *(tmp + i) != 0x0a && *(tmp + i) != 0x0d)
            break;
        *(tmp + i) = 0;
    }
    free(buf);
    return msgs;
}

/* i changed this... This function is not to understimate when player talk alot
 * in areas which alot if map objects... This is one of this little extra cpu eaters
 * which adds cput time here and there.
 * i added P_MAGIC_EAR as map flag - later we should use a chained list in the map headers
 * perhaps. I also removed the npcs from the map search and use the target system. 
 * This IS needed because in alot of cases in the past you was not able to target the
 * npc you want - if the search routine find another npc first, the other was silenced.
 * MT-2003
 */
void communicate(object *op, char *txt)
{
    object     *npc;
    mapstruct  *m;
    int         i, xt, yt;

    char        buf[HUGE_BUF];

    if (!txt)
        return;


    /* with target, only player can talk to npc... for npc to npc talk we need so or so a script,
    * and there we have then to add the extra interface.
    */

    /* thats the whisper code - i will add a /whisper for it and remove it from here */
    /*
    if(op->type == PLAYER)
    {
        if(op->contr->target_object && op->contr->target_object_count==op->contr->target_object->count)
        {
            if(op->contr->target_object->type == PLAYER)
            {
                if(op != op->contr->target_object)
                {
                    sprintf(buf, "%s whispers to you: ",query_name(op));
                    strncat(buf, txt, MAX_BUF - strlen(buf)-1);
                    buf[MAX_BUF-1]=0;
                    new_draw_info(NDI_WHITE|NDI_GREEN,0, op->contr->target_object, buf);
                    sprintf(buf, "you whispers to %s: ",query_name(op->contr->target_object));
                    strncat(buf, txt, MAX_BUF - strlen(buf)-1);
                    buf[MAX_BUF-1]=0;
                    new_draw_info(NDI_WHITE|NDI_GREEN,0, op, buf);
                    sprintf(buf, "%s whispers something to %s.",query_name(op),query_name(op->contr->target_object));
                    new_info_map_except2(NDI_WHITE,op->map, op, op->contr->target_object, buf);
                    if(op->contr->target_object->map && op->contr->target_object->map != op->map)
                        new_info_map_except2(NDI_WHITE,op->contr->target_object->map, op, op->contr->target_object, buf);
                }
                else 
                {
                    sprintf(buf, "%s says: ",query_name(op));
                    strncat(buf, txt, MAX_BUF - strlen(buf)-1);
                    buf[MAX_BUF-1]=0;
                    new_info_map(NDI_WHITE,op->map, buf);
                }
            }
            else 
            {
                sprintf(buf, "%s says to %s: ",query_name(op),query_name(op->contr->target_object));
                strncat(buf, txt, MAX_BUF - strlen(buf)-1);
                buf[MAX_BUF-1]=0;
                new_info_map_except(NDI_WHITE,op->map, op, buf);
                if(op->contr->target_object->map && op->contr->target_object->map != op->map)
                    new_info_map_except(NDI_WHITE,op->contr->target_object->map, op, buf);
                sprintf(buf, "you say to %s: ",query_name(op->contr->target_object));
                strncat(buf, txt, MAX_BUF - strlen(buf)-1);
                buf[MAX_BUF-1]=0;
                new_draw_info(NDI_WHITE,0, op, buf);
                talk_to_npc(op, op->contr->target_object,txt);
            }
        }
        else
        {
            sprintf(buf, "%s says: ",query_name(op));
            strncat(buf, txt, MAX_BUF - strlen(buf)-1);
            buf[MAX_BUF-1]=0;
            new_info_map(NDI_WHITE,op->map, buf);
        }
    }
    else
    {
        sprintf(buf, "%s says: ",query_name(op));
        strncat(buf, txt, MAX_BUF - strlen(buf)-1);
        buf[MAX_BUF-1]=0;
        new_info_map(NDI_WHITE,op->map, buf);
    }
    */

    /* npc chars can hook in here with
     * monster.Communicate("/kiss Fritz")
     * we need to catch the emote here.
     */
    if (*txt == '/' && op->type != PLAYER)
    {
        CommArray_s    *csp;
        char           *cp  = NULL;

        /* remove the command from the parameters */
        strncpy(buf, txt, HUGE_BUF - 1);
        buf[HUGE_BUF - 1] = '\0';

        cp = strchr(buf, ' ');

        if (cp)
        {
            *(cp++) = '\0';
            cp = cleanup_string(cp);
            if (cp && *cp == '\0')
                cp = NULL;
        }

        csp = find_command_element(buf, CommunicationCommands, CommunicationCommandSize);
        if (csp)
        {
            csp->func(op, cp);
            return;
        }
        return;
    }

    sprintf(buf, "%s says: ", query_name(op));
    strncat(buf, txt, MAX_BUF - strlen(buf) - 1);
    buf[MAX_BUF - 1] = 0;
    new_info_map(NDI_WHITE, op->map, op->x, op->y, MAP_INFO_NORMAL, buf);

    for (i = 0; i <= SIZEOFFREE2; i++)
    {
        xt = op->x + freearr_x[i];
        yt = op->y + freearr_y[i];
        if ((m = out_of_map(op->map, &xt, &yt)))
        {
            if (GET_MAP_FLAGS(m, xt, yt) & (P_MAGIC_EAR | P_IS_ALIVE)) /* quick check we have a magic ear */
            {
                /* ok, browse now only on demand */
                for (npc = get_map_ob(m, xt, yt); npc != NULL; npc = npc->above)
                {
                    /* avoid talking to self */
                    if (op != npc)
                    {
                        /* the ear ... don't break because it can be mutiple on a node or more in the area */
                        if (npc->type == MAGIC_EAR)
                            (void) talk_to_wall(npc, txt); /* Maybe exit after 1. success? */
                        else if (QUERY_FLAG(npc, FLAG_ALIVE))
                            talk_to_npc(op, npc, txt);
                    }
                }
            }
        }
    }
}

/* this communication thingy is ugly - ugly in the way it use malloc for getting
buffers for storing parts of the msg text??? There should be many smarter ways
to handle it
*/
int talk_to_npc(object *op, object *npc, char *txt)
{
    msglang    *msgs;
    int         i, j;
    object     *cobj;
#ifdef PLUGINS

    /* GROS: Handle for plugin say event */
    if (npc->event_flags & EVENT_FLAG_SAY)
    {
        CFParm  CFP;
        int     k, l, m;
        object *event_obj   = get_event_object(npc, EVENT_SAY);
        k = EVENT_SAY;
        l = SCRIPT_FIX_ACTIVATOR;
        m = 0;
        CFP.Value[0] = &k;
        CFP.Value[1] = op;
        CFP.Value[2] = npc;
        CFP.Value[3] = NULL;
        CFP.Value[4] = txt;
        CFP.Value[5] = &m;
        CFP.Value[6] = &m;
        CFP.Value[7] = &m;
        CFP.Value[8] = &l;
        CFP.Value[9] = (char *) STRING_OBJ_RACE(event_obj);
        CFP.Value[10] = (char *) STRING_OBJ_SLAYING(event_obj);

        if (findPlugin(event_obj->name) >= 0)
        {
//#define TIME_SCRIPTS        
#ifdef TIME_SCRIPTS        
            int             count   = 0;
            struct timeval  start, stop;
            long long   start_u, stop_u;
            gettimeofday(&start, NULL);

            for (count = 0; count < 10000; count++)
                ((PlugList[findPlugin(event_obj->name)].eventfunc) (&CFP));

            gettimeofday(&stop, NULL);
            start_u = start.tv_sec * 1000000 + start.tv_usec;
            stop_u  = stop.tv_sec * 1000000 + stop.tv_usec;   

            LOG(llevDebug, "running time: %2.4f s\n", (stop_u - start_u) / 1000000.0);
#else    
            ((PlugList[findPlugin(event_obj->name)].eventfunc) (&CFP));
#endif    
            return 0;
        }
    }

    /* GROS - Here we let the objects inside inventories hear and answer, too. */
    /* This allows the existence of "intelligent" weapons you can discuss with */
    for (cobj = npc->inv; cobj != NULL;)
    {
        if (cobj->event_flags & EVENT_FLAG_SAY)
        {
            CFParm  CFP;
            int     k, l, m;
            object *event_obj   = get_event_object(cobj, EVENT_SAY);
            k = EVENT_SAY;
            l = SCRIPT_FIX_ALL;
            m = 0;
            CFP.Value[0] = &k;
            CFP.Value[1] = op;
            CFP.Value[2] = cobj;
            CFP.Value[3] = npc;
            CFP.Value[4] = txt;
            CFP.Value[5] = &m;
            CFP.Value[6] = &m;
            CFP.Value[7] = &m;
            CFP.Value[8] = &l;
            CFP.Value[9] = (char *) (STRING_OBJ_RACE(event_obj));
            CFP.Value[10] = (char *) (STRING_OBJ_SLAYING(event_obj));
            if (event_obj && findPlugin(event_obj->name) >= 0)
            {
                ((PlugList[findPlugin(event_obj->name)].eventfunc) (&CFP));
                return 0;
            }
            else
            {
                LOG(llevBug, "An object (%s) had a event flag but no event object (SAY)\n", cobj->name);
            }
        }
        cobj = cobj->below;
    }

#endif
    if (npc->msg == NULL || *npc->msg != '@')
    {
        /*new_draw_info_format(NDI_UNIQUE,0,op, "%s has nothing to say.", query_name(npc));*/
        return 0;
    }
    if ((msgs = parse_message(npc->msg)) == NULL)
        return 0;
#if 0 /* Turn this on again when enhancing parse_message() */
  if(debug)
    dump_messages(msgs);
#endif
    for (i = 0; msgs->messages[i]; i++)
        for (j = 0; msgs->keywords[i][j]; j++)
            if (msgs->keywords[i][j][0] == '*' || re_cmp(txt, msgs->keywords[i][j]))
            {
                char    buf[MAX_BUF];
                if (op->type != PLAYER) /* a npc talks to another one - show both in white */
                {
                    /* if a message starts with '/', we assume a emote */
                    /* we simply hook here in the emote msg list */
                    if (*msgs->messages[i] == '/')
                    {
                        CommArray_s    *csp;
                        char           *cp  = NULL;
                        char            buf[MAX_BUF]; 

                        strncpy(buf, msgs->messages[i], MAX_BUF - 1);
                        buf[MAX_BUF - 1] = '\0';

                        cp = strchr(buf, ' ');
                        if (cp)
                        {
                            *(cp++) = '\0';
                            cp = cleanup_string(cp);
                            if (cp && *cp == '\0')
                                cp = NULL;

                            if (cp && *cp == '%')
                                cp = (char *) op->name;
                        }

                        csp = find_command_element(buf, CommunicationCommands, CommunicationCommandSize);
                        if (csp)
                            csp->func(npc, cp);
                    }
                    else
                    {
                        sprintf(buf, "%s says: %s", query_name(npc), msgs->messages[i]);
                        new_info_map_except(NDI_UNIQUE, op->map, op->x, op->y, MAP_INFO_NORMAL, op, op, buf);
                    }
                }
                else /* if a npc is talking to a player, is shown navy and with a seperate "xx says:" line */
                {
                    /* if a message starts with '/', we assume a emote */
                    /* we simply hook here in the emote msg list */
                    if (*msgs->messages[i] == '/')
                    {
                        CommArray_s    *csp;
                        char           *cp  = NULL;
                        char            buf[MAX_BUF]; 

                        strncpy(buf, msgs->messages[i], MAX_BUF - 1);
                        buf[MAX_BUF - 1] = '\0';

                        cp = strchr(buf, ' ');
                        if (cp)
                        {
                            *(cp++) = '\0';
                            cp = cleanup_string(cp);
                            if (cp && *cp == '\0')
                                cp = NULL;

                            if (cp && *cp == '%')
                                cp = (char *) op->name;
                        }

                        csp = find_command_element(buf, CommunicationCommands, CommunicationCommandSize);
                        if (csp)
                            csp->func(npc, cp);
                    }
                    else
                    {
                        sprintf(buf, "%s says:", query_name(npc)); 
                        new_draw_info(NDI_NAVY | NDI_UNIQUE, 0, op, buf);
                        new_draw_info(NDI_NAVY | NDI_UNIQUE, 0, op, msgs->messages[i]);
                        sprintf(buf, "%s talks to %s.", query_name(npc), query_name(op));
                        new_info_map_except(NDI_UNIQUE, op->map, op->x, op->y, MAP_INFO_NORMAL, op, op, buf);
                    }
                }
                free_messages(msgs);
                return 1;
            }
    free_messages(msgs);
    return 0;
}

int talk_to_wall(object *npc, char *txt)
{
    msglang    *msgs;
    int         i, j;

    if (npc->msg == NULL || *npc->msg != '@')
        return 0;
    if ((msgs = parse_message(npc->msg)) == NULL)
        return 0;
#if 0 /* Turn this on again when enhancing parse_message() */
  if(settings.debug >= llevDebug)
    dump_messages(msgs);
#endif
    for (i = 0; msgs->messages[i]; i++)
        for (j = 0; msgs->keywords[i][j]; j++)
            if (msgs->keywords[i][j][0] == '*' || re_cmp(txt, msgs->keywords[i][j]))
            {
                if (msgs->messages[i] && *msgs->messages[i] != 0)
                    new_info_map(NDI_NAVY | NDI_UNIQUE, npc->map, npc->x, npc->y, MAP_INFO_NORMAL, msgs->messages[i]);
                free_messages(msgs);
                use_trigger(npc);
                return 1;
            }
    free_messages(msgs);
    return 0;
}

/*
 * spawn point releated function
 * MT: perhaps its time to make a new module?
 * Gecko: YES!!
 */

/* drop a monster on the map, by copying a monster object or
 * monster object head. Add treasures.
 */
static object * spawn_monster(object *gen, object *orig, int range)
{
    int         i;
    object     *op, *head = NULL, *prev = NULL, *ret = NULL;
    archetype  *at  = gen->arch;

    i = find_first_free_spot2(at, orig->map, orig->x, orig->y, 0, range);
    if (i == -1)
        return NULL; 
    while (at != NULL)
    {
        op = get_object();
        if (head == NULL) /* copy single/head from spawn inventory */
        {
            gen->type = MONSTER;
            copy_object(gen, op);
            gen->type = SPAWN_POINT_MOB;
            ret = op;
        }
        else /* but the tails for multi arch from the clones */
        {
            copy_object(&at->clone, op);
        }
        op->x = orig->x + freearr_x[i] + at->clone.x;
        op->y = orig->y + freearr_y[i] + at->clone.y;
        op->map = orig->map;
        if (head != NULL)
            op->head = head,prev->more = op;
        if (OBJECT_FREE(op))
            return NULL;
        if (op->randomitems != NULL)
            create_treasure_list(op->randomitems, op, 0, op->level ? op->level : orig->map->difficulty, T_STYLE_UNSET,
                                 ART_CHANCE_UNSET, 0, NULL);
        if (head == NULL)
            head = op;
        prev = op;
        at = at->more;
    }
    return ret; /* return object ptr to our spawn */
}

/* check the current darkness on this map allows to spawn 
 * 0: not allowed, 1: allowed
 */
static inline int spawn_point_darkness(object *spoint, int darkness)
{
    int map_light;

    if (!spoint->map)
        return 0;

    if (MAP_OUTDOORS(spoint->map)) /* outdoor map */
        map_light = world_darkness;
    else
    {
        if (MAP_DARKNESS(spoint->map) == -1)
            map_light = MAX_DARKNESS;
        else
            map_light = MAP_DARKNESS(spoint->map);
    }

    if (darkness < 0)
    {
        if (map_light < -darkness)
            return 1;
    }
    else
    {
        if (map_light > darkness)
            return 1;
    }
    return 0;
}


/* central spawn point function.
 * Control, generate or remove the generated object.
 */
void spawn_point(object *op)
{
    int     rmt;
    object *tmp, *mob, *next, *item;
    object *tmp2, *next2;

    if (op->enemy)
    {
        if (OBJECT_VALID(op->enemy, op->enemy_count)) /* all ok, our spawn have fun */
        {
            if (op->last_eat) /* check darkness if needed */
            {
                /* 1 = darkness is ok */
                if (spawn_point_darkness(op, op->last_eat))
                    return;

                /* darkness has changed - now remove the spawned monster */
                remove_ob(op->enemy);
                check_walk_off(op->enemy, NULL, MOVE_APPLY_VANISHED);
            }
            else
                return;
        }
        op->enemy = NULL; /* spawn point has nothing spawned */
    }

    /* a set sp value will override the spawn chance.
     * with that "trick" we force for map loading the
     * default spawns of the map because sp is 0 as default.
     */
    /*LOG(-1,"SPAWN...(%d,%d)",op->x, op->y);*/
    if (op->stats.sp == -1)
    {
        int gg;
        /* now lets decide we will have a spawn event */
        if (op->last_grace <= -1) /* never */
        {
            /*LOG(-1," closed (-1)\n");*/
            return;
        }
        if (op->last_grace && (gg = (RANDOM() % (op->last_grace + 1)))) /* if >0 and random%x is NOT null ... */
        {
            /*LOG(-1," chance: %d (%d)\n",gg,op->last_grace);*/
            return;
        }

        op->stats.sp = (RANDOM() % SPAWN_RANDOM_RANGE);
    }
    /*LOG(-1," hit!: %d\n",op->stats.sp);*/

    if (!op->inv) /* spawn point without inventory! */
    {
        LOG(llevBug, "BUG: Spawn point without inventory!! --> map %s (%d,%d)\n",
            op->map ? (op->map->path ? op->map->path : ">no path<") : ">no map<", op->x, op->y);
        /* kill this spawn point - its useless and need to fixed from the map maker/generator */
        remove_ob(op);
        check_walk_off(op, NULL, MOVE_APPLY_VANISHED);
        return;
    }
    /* now we move through the spawn point inventory and
     * get the mob with a number under this value AND nearest.
     */
    for (rmt = 0,mob = NULL,tmp = op->inv; tmp; tmp = next)
    {
        next = tmp->below;

        if (tmp->type != SPAWN_POINT_MOB)
            LOG(llevBug, "BUG: spawn point in map %s (%d,%d) with wrong type object (%d) in inv: %s\n",
                op->map ? op->map->path : "<no map>", op->x, op->y, tmp->type, query_name(tmp));
        else if ((int) tmp->enemy_count <= op->stats.sp && (int) tmp->enemy_count >= rmt)
        {
            /* we have a possible hit - control special settings now */
            if (tmp->last_eat) /* darkness */
            {
                /* 1: darkness on map of spawn point is ok */
                if (!spawn_point_darkness(op, tmp->last_eat))
                    continue;
            }

            rmt = (int) tmp->enemy_count;
            mob = tmp;
        }
        /*      LOG(llevInfo,"inv -> %s (%d :: %d - %f)\n", tmp->name, op->stats.sp, tmp->enemy_count, tmp->speed_left);*/
    }
    /* we try only ONE time a respawn of a pre setting - so careful! */
    rmt = op->stats.sp;
    op->stats.sp = -1;
    if (!mob) /* well, this time we spawn nothing */
        return;

    tmp = mob->inv; /* quick save the def mob inventory */
    if (!(mob = spawn_monster(mob, op, op->last_heal)))
        return; /* that happens when we have no free spot....*/

    /* setup special monster -> spawn point values */
    op->last_eat = 0;
    if (mob->last_eat) /* darkness controled spawns */
    {
        op->last_eat = mob->last_eat;
        mob->last_eat = 0;
    }

    /* we have a mob - now insert a copy of all items the spawn point mob has.
     * take care about RANDOM DROP objects.
     * usually these items are put from the map maker inside the spawn mob inv.
     * remember that these are additional items to the treasures list ones.
     */
    for (; tmp; tmp = next)
    {
        next = tmp->below;
        if (tmp->type == TYPE_RANDOM_DROP)
        {
            if (!tmp->weight_limit || !(RANDOM() % (tmp->weight_limit + 1))) /* skip this container - drop the ->inv */
            {
                for (tmp2 = tmp->inv; tmp2; tmp2 = next2)
                {
                    next2 = tmp2->below;
                    if (tmp2->type == TYPE_RANDOM_DROP)
                        LOG(llevDebug,
                            "DEBUG:: Spawn:: RANDOM_DROP (102) not allowed inside RANDOM_DROP.mob:>%s< map:%s (%d,%d)\n",
                            query_name(mob), op->map
                          ? op->map->path
                          : "BUG: S-Point without map!", op->x, op->y);
                    else
                    {
                        item = get_object();
                        copy_object(tmp2, item);
                        insert_ob_in_ob(item, mob);      /* and put it in the mob */
                    }
                }
            }
        }
        else /* remember this can be sys_objects too! */
        {
            item = get_object();
            copy_object(tmp, item);
            insert_ob_in_ob(item, mob);      /* and put it in the mob */
        }
    }

    op->last_sp = rmt; /* this is the last rand() for what we have spawned! */

    op->enemy = mob; /* chain the mob to our spawn point */
    op->enemy_count = mob->count;

    /* perhaps we have later more unique mob setting - then we can store it here too.
     */
    tmp = arch_to_object(op->other_arch); /* create spawn info */
    tmp->owner = op; /* chain spawn point to our mob */
    insert_ob_in_ob(tmp, mob);      /* and put it in the mob */

    SET_MULTI_FLAG(mob, FLAG_SPAWN_MOB); /* FINISH: now mark our mob as a spawn */
    fix_monster(mob); /* fix all the values and add in possible abilities or forces ... */
    if (!insert_ob_in_map(mob, mob->map, op, 0)) /* *now* all is done - *now* put it on map */
        return;
    if (QUERY_FLAG(mob, FLAG_FRIENDLY))
        add_friendly_object(mob);
}
